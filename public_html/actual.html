<!DOCTYPE html>
<html lang="es">
<header id="main-header">
  <div class="container header-content">
    <img src="img/logo-sti1.png" alt="Logo STI" class="logo" width="80" height="80" decoding="async">
    <nav class="main-nav ocultar-movil"></nav>
  </div>
</header>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Actual</title>
  <link href="https://fonts.googleapis.com/css2?family=Exo:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body{
      margin:0;
      background:#0b0d12;
      color:#e0e0e0;
      font-family:'Exo',sans-serif;
      text-align:center;
      padding:60px 20px;
    }
    .box{
      max-width:720px;
      margin:auto;
      background:rgba(15,20,30,.6);
      padding:40px;
      border:1px solid rgba(92,200,255,.22);
      border-radius:12px;
      box-shadow:0 0 18px rgba(92,200,255,.15);
    }
    h1{
      color:#58a6ff;
      font-size:1.8rem;
      margin-bottom:12px;
    }
    p{
      color:#aebcd4;
      font-size:15px;
      line-height:1.6;
    }

    /* Bot√≥n base */
    a.btn{
      display:inline-block;
      padding:12px 26px;
      border-radius:32px;
      color:#fff;
      text-decoration:none;
      font-weight:700;
      transition:all .3s ease;
      white-space:nowrap;
    }

    /* Azul (ya existente) */
    a.btn-blue{
      background:linear-gradient(180deg,#4fcaff 0%,#0a74c5 45%,#002f5f 100%);
      box-shadow:
        inset 0 2px 6px rgba(255,255,255,.25),
        inset 0 -2px 6px rgba(0,0,0,.30),
        0 0 0 1px rgba(92,200,255,.38),
        0 0 18px rgba(92,200,255,.38),
        0 0 42px rgba(92,200,255,.25);
    }
    a.btn-blue:hover{
      background:linear-gradient(180deg,#62d2ff 0%,#0fa1ff 50%,#003a73 100%);
      box-shadow:
        inset 0 2px 6px rgba(255,255,255,.30),
        inset 0 -2px 8px rgba(0,0,0,.35),
        0 0 0 1px rgba(92,200,255,.55),
        0 0 26px rgba(92,200,255,.55),
        0 0 64px rgba(92,200,255,.35);
    }

    /* Verde metalizado WhatsApp */
    a.btn-wa{
      background:linear-gradient(180deg,#4cf28a 0%, #10b45a 45%, #06522b 100%);
      box-shadow:
        inset 0 2px 6px rgba(255,255,255,.22),
        inset 0 -2px 6px rgba(0,0,0,.35),
        0 0 0 1px rgba(56,255,161,.40),
        0 0 18px rgba(56,255,161,.35),
        0 0 42px rgba(56,255,161,.25);
      border:0;
    }
    a.btn-wa:hover{
      background:linear-gradient(180deg,#72f7a2 0%, #17ce6c 50%, #0a6b3a 100%);
      box-shadow:
        inset 0 2px 7px rgba(255,255,255,.28),
        inset 0 -2px 8px rgba(0,0,0,.38),
        0 0 0 1px rgba(56,255,161,.6),
        0 0 26px rgba(56,255,161,.55),
        0 0 64px rgba(56,255,161,.35);
    }

    /* Contenedor de botones: centrados y con espacio */
    .btn-row{
      margin-top:22px;
      display:flex;
      justify-content:center;
      align-items:center;
      gap:14px;
      flex-wrap:wrap;
    }

    /* Responsive: apilar en m√≥viles */
    @media (max-width:540px){
      .btn-row{gap:10px;}
      a.btn{width:100%; max-width:320px;}
    }
  </style>
</head>
<body>
  <div class="box">
    <h1>Actual</h1>
    <p>
        // server.js V4.8.3 ‚Äî STI Chat (Redis + Tickets + Transcript) + NameFix + CORS + Reload + GreeterFix + FlowFix
// Resumen del flujo y features implementadas
// - Estados: ASK_NAME ‚Üí ASK_PROBLEM ‚Üí ASK_DEVICE ‚Üí BASIC/ADVANCED/ESCALATE
// - Sesi√≥n por 'x-session-id' / 'sid' (si ya hay nombre no reinicia)
// - pendingUtterance: guarda el problema si lo mandan antes del nombre
// - CORS s√≥lido con OPTIONS para preflight
// - Endpoints: /  /api/health  /api/reload(GET/POST)  /api/greeting  /api/chat
//              /api/transcript/:sid  /api/whatsapp-ticket  /ticket/:id  /api/sessions  /api/reset
// - OpenAI opcional para an√°lisis/steps; si no hay API Key usa fallback local

import 'dotenv/config';            // Carga variables de entorno desde .env
import express from 'express';     // Framework HTTP
import cors from 'cors';           // Middleware CORS
import fs from 'fs';               // FileSystem para logs, tickets y transcripts
import path from 'path';           // Utilidades de rutas
import OpenAI from 'openai';       // SDK OpenAI (opcional)

// ===== OpenAI (opcional) =====
const OPENAI_MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini';  // Modelo por defecto
// Instancia de cliente OpenAI solo si hay API key (evita crashear en local)
const openai = process.env.OPENAI_API_KEY ? new OpenAI({ apiKey: process.env.OPENAI_API_KEY }) : null;

// ===== Persistencia / paths =====
// Carpetas base (se pueden mapear a vol√∫menes en Render/Docker)
const DATA_BASE       = process.env.DATA_BASE       || '/data';
const TRANSCRIPTS_DIR = process.env.TRANSCRIPTS_DIR || path.join(DATA_BASE, 'transcripts');
const TICKETS_DIR     = process.env.TICKETS_DIR     || path.join(DATA_BASE, 'tickets');
const LOGS_DIR        = process.env.LOGS_DIR        || path.join(DATA_BASE, 'logs');
// URL p√∫blica del backend para construir links (tickets, og:image, etc.)
const PUBLIC_BASE_URL = process.env.PUBLIC_BASE_URL || 'https://sti-rosario-ai.onrender.com';
// N√∫mero de WhatsApp destino para derivaciones
const WHATSAPP_NUMBER = process.env.WHATSAPP_NUMBER || '5493417422422';

// Crea directorios si no existen (recursivo)
for (const d of [TRANSCRIPTS_DIR, TICKETS_DIR, LOGS_DIR]) {
  try { fs.mkdirSync(d, { recursive: true }); } catch {}
}
const nowIso = () => new Date().toISOString();  // Helper timestamp ISO

// ===== Carga chat JSON =====
// Ruta al archivo de configuraci√≥n conversacional (nlp, steps, labels)
const CHAT_JSON_PATH = process.env.CHAT_JSON || path.join(process.cwd(), 'sti-chat.json');
let CHAT = {};             // Objeto con todo el JSON cargado
let deviceMatchers = [];   // Cache de regex para dispositivos
let issueMatchers  = [];   // Cache de regex para issues

// Carga/parsing de sti-chat.json, compila regex de devices/issues para rendimiento
function loadChat() {
  try {
    CHAT = JSON.parse(fs.readFileSync(CHAT_JSON_PATH, 'utf8'));
    console.log('[chat] ‚úÖ Cargado', CHAT.version, 'desde', CHAT_JSON_PATH);
    deviceMatchers = (CHAT?.nlp?.devices || []).map(d => ({ key: d.key, rx: new RegExp(d.rx, 'i') }));
    issueMatchers  = (CHAT?.nlp?.issues  || []).map(i => ({ key: i.key, rx: new RegExp(i.rx, 'i') }));
  } catch (e) {
    console.error('[chat] ‚ùå No pude cargar sti-chat.json:', e.message);
    CHAT = {}; deviceMatchers = []; issueMatchers = [];
  }
}
loadChat();

// Helpers de NLP (humanizaci√≥n de issue y detecciones por regex)
const issueHuman = (k) => CHAT?.nlp?.issue_labels?.[k] || 'el problema';
function detectDevice(txt = '') { for (const d of deviceMatchers) if (d.rx.test(txt)) return d.key; return null; }
function detectIssue (txt = '') { for (const i of issueMatchers)  if (i.rx.test(txt)) return i.key; return null; }

// Template de respuesta por defecto (permite personalizar en JSON)
function tplDefault({ nombre = '', device = 'equipo', issueKey = null }) {
  const base = CHAT?.nlp?.response_templates?.default ||
    'Entiendo, {{nombre}}. Revisemos tu {{device}} con {{issue_human}}.';
  return base.replace('{{nombre}}', nombre || '')
             .replace('{{device}}', device || 'equipo')
             .replace('{{issue_human}}', issueHuman(issueKey));
}

// ===== Store de sesiones (Redis u otro) =====
// getSession/saveSession/listActiveSessions est√°n abstra√≠dos en sessionStore.js
import { getSession, saveSession, listActiveSessions } from './sessionStore.js';

// ===== App =====
const app = express();
app.set('trust proxy', 1);  // Conf√≠a en cabeceras de proxy (Render/NGINX) para IP real

// CORS fuerte + OPTIONS handler (preflight)
app.use(cors({
  origin: true,                 // Permite cualquier origen (o ajust√° a tu dominio)
  credentials: true,            // Permite cookies/headers de auth
  methods: ['GET','POST','OPTIONS'],
  allowedHeaders: ['Content-Type','x-session-id','x-session-fresh'] // headers custom
}));
app.options('*', cors({
  origin: true,
  credentials: true,
  methods: ['GET','POST','OPTIONS'],
  allowedHeaders: ['Content-Type','x-session-id','x-session-fresh']
}));

// Body parsers (JSON + urlencoded)
app.use(express.json({ limit: '2mb' }));
app.use(express.urlencoded({ extended: false }));

// No cache global (evita que proxies sirvan saludos viejos)
app.use((req, res, next) => { res.set('Cache-Control','no-store'); next(); });

// Landing amigable (√∫til para verificar deploy vivo)
app.get('/', (_req, res) => {
  res.type('html').send(`<!doctype html><meta charset="utf-8">
  <style>body{font:14px system-ui;margin:24px}a{color:#2563eb;text-decoration:none}</style>
  <h1>üöÄ STI Rosario AI</h1>
  <p>Servicio en l√≠nea. Endpoints √∫tiles:</p>
  <ul>
    <li><a href="/api/health">/api/health</a></li>
    <li><a href="/api/sessions">/api/sessions</a></li>
  </ul>`);
});

// ===== Estados / helpers =====
// M√°quina de estados de la conversaci√≥n
const STATES = {
  ASK_NAME: 'ask_name',           // pedir nombre
  ASK_PROBLEM: 'ask_problem',     // pedir problema
  ASK_DEVICE: 'ask_device',       // pedir equipo/dispositivo
  BASIC_TESTS: 'basic_tests',     // pasos b√°sicos (desde JSON o AI)
  BASIC_TESTS_AI: 'basic_tests_ai', // pasos b√°sicos generados por AI
  ADVANCED_TESTS: 'advanced_tests', // pasos avanzados
  ESCALATE: 'escalate',           // derivar a humano/WhatsApp
};

// Palabras que NO deben interpretarse como nombre (evita ‚Äúpc‚Äù, ‚Äúrouter‚Äù, etc.)
const TECH_WORDS = /^(pc|notebook|netbook|laptop|ultrabook|macbook|monitor|pantalla|teclado|mouse|raton|touchpad|trackpad|impresora|printer|scanner|escaner|router|modem|switch|hub|repetidor|accesspoint|servidor|server|cpu|gabinete|fuente|mother|motherboard|placa|placa madre|gpu|video|grafica|ram|memoria|disco|ssd|hdd|pendrive|usb|auricular|auriculares|headset|microfono|camara|webcam|altavoz|parlante|red|ethernet|wifi|wi-?fi|bluetooth|internet|nube|cloud|telefono|celular|movil|smartphone|tablet|ipad|android|iphone|ios|windows|linux|macos|bios|uefi|driver|controlador|actualizacion|formateo|virus|malware|pantallazo|backup|respaldo|sistema operativo|office|problema|error|fallo|falla|bug|reparacion|tecnico|compu|computadora|equipo|hardware|software|programa|sistema)$/i;

// Heur√≠stica para detectar que el texto describe un problema (no un nombre)
const problemHint = /(no (prende|enciende|arranca|funciona|anda|conecta|detecta|reconoce|responde|da se√±al|muestra imagen|carga|enciende la pantalla)|no (da|tiene) (video|imagen|sonido|internet|conexion|red|wifi|se√±al)|no inicia|no arranca|no anda|no funca|lento|va lento|se tilda|se cuelga|se congela|pantalla (negra|azul|blanca|con rayas)|sin imagen|sin sonido|sin se√±al|se apaga|se reinicia|se reinicia solo|no carga|no enciende|no muestra nada|hace ruido|no hace nada|tiene olor|saca humo|parpadea|no detecta|no reconoce|no conecta|problema|error|fallo|falla|bug|no abre|no responde|bloqueado|traba|lag|p(√©|e)rdida de conexi(√≥|o)n|sin internet|sin wi[- ]?fi|no se escucha|no se ve|no imprime|no escanea|sin color|no gira|no arranca el ventilador)/i;

// Validaci√≥n y extracci√≥n de nombre (conformidad b√°sica y frases ‚Äúsoy/mi nombre es‚Äù)
function isValidName(text) {
  if (!text) return false;
  const t = String(text).trim();
  if (TECH_WORDS.test(t)) return false;
  return /^[a-z√°√©√≠√≥√∫√±]{3,20}$/i.test(t);
}
function extractName(text) {
  if (!text) return null;
  const t = String(text).trim();
  const m = t.match(/^(?:soy|me llamo|mi nombre es)\s+([a-z√°√©√≠√≥√∫√±]{3,20})$/i);
  if (m) return m[1];
  if (isValidName(t)) return t;
  return null;
}
const cap = s => s ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : s; // Capitaliza nombre
const withOptions = (obj) => ({ options: [], ...obj }); // Asegura campo options en respuestas

// === Voseo: convierte instrucciones neutras/usted a voseo rioplatense ===
// Es seguro: si no encuentra patrones, devuelve el mismo texto.
function arVoseo(s) {
  let t = String(s || '').trim();
  const repl = [
    [/\bpresione\b/gi, 'apret√°'],
    [/\bpresionar\b/gi, 'apretar'],
    [/\bhaga\b/gi, 'hac√©'],
    [/\bhaz\b/gi, 'hac√©'],
    [/\bverifique\b/gi, 'verific√°'],
    [/\bintente\b/gi, 'prob√°'],
    [/\bpruebe\b/gi, 'prob√°'],
    [/\bquiera\b/gi, 'quer√©s'],
    [/\bpuede\b/gi, 'pod√©s'],
    [/\bconecte\b/gi, 'conect√°'],
    [/\bdesconecte\b/gi, 'desconect√°'],
    [/\bmantenga\b/gi, 'manten√©'],
    [/\breinicie\b/gi, 'reinici√°'],
  ];
  for (const [rx, to] of repl) t = t.replace(rx, to);
  return t;
}
// Map seguro que no rompe si viene undefined/null
const mapVoseoSafe = (arr) => Array.isArray(arr) ? arr.map(arVoseo) : [];

// Normaliza el sessionId de headers/body/query; genera uno si no viene
function getSessionId(req) {
  // headers en node est√°n en min√∫scula
  const hSid = (req.headers['x-session-id'] || '').toString().trim();
  const bSid = (req.body && (req.body.sessionId || req.body.sid)) ? String(req.body.sessionId || req.body.sid).trim() : '';
  const qSid = (req.query && (req.query.sessionId || req.query.sid)) ? String(req.query.sessionId || req.query.sid).trim() : '';
  const raw = hSid || bSid || qSid;
  return raw || `srv-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
}
app.use((req, _res, next) => { req.sessionId = getSessionId(req); next(); });

// ===== Config diagn√≥stico OA =====
// Umbral m√≠nimo de confianza para aceptar predicci√≥n AI/regex
const OA_MIN_CONF = Number(process.env.OA_MIN_CONF || 0.6);

/* =======================================================================
   ===== An√°lisis con OpenAI (MEJORADO con normalizaci√≥n y sin√≥nimos) =====
   - Devuelve {device, issueKey, confidence} con normalizaci√≥n fuerte
   - Tolerante a ```json y a respuestas no estrictas
   - Mapea sin√≥nimos (teclado USB/inal√°mbrico => "teclado")
   - Completa issueKey espec√≠fica cuando el modelo queda gen√©rico
   ======================================================================= */

const CANON_DEVICES = [
  'pc','notebook','monitor','teclado','mouse','impresora','almacenamiento','red','camara','microfono'
];

const DEVICE_SYNONYMS = [
  [/^(pc|computadora|compu|cpu|gabinete)$/i, 'pc'],
  [/^(notebook|laptop|netbook|ultrabook|macbook)$/i, 'notebook'],
  [/^(monitor|pantalla)$/i, 'monitor'],
  [/^(teclado|keyboard|kb)$/i, 'teclado'],
  [/^(mouse|rat[o√≥]n|touchpad|trackpad)$/i, 'mouse'],
  [/^(impresora|printer)$/i, 'impresora'],
  [/^(disco|ssd|hdd|pendrive|usb|memoria usb|unidad|externo)$/i, 'almacenamiento'],
  [/^(wifi|wi-?fi|internet|red|ethernet|router|m[√≥o]dem|modem)$/i, 'red'],
  [/^(c[a√°]mara|webcam)$/i, 'camara'],
  [/^(microf[o√≥]no|mic)$/i, 'microfono'],
];

function normalizeDevice(s) {
  const t = String(s || '').trim().toLowerCase();
  for (const [rx, canon] of DEVICE_SYNONYMS) if (rx.test(t)) return canon;
  return CANON_DEVICES.includes(t) ? t : null;
}

// Issue keys can√≥nicas que usamos en nlp. Pod√©s ampliar seg√∫n tu JSON.
const ISSUE_KEYS = [
  'no_prende','no_internet','wifi_no_conecta','pantalla_negra','no_imagen','sin_sonido',
  'teclado_no_detecta','mouse_no_detecta','impresora_no_detecta','usb_no_detecta',
  'disco_no_detecta','camara_no_detecta','microfono_no_detecta'
];

function normalizeIssue(device, issueKey, originalText='') {
  let k = (issueKey || '').toLowerCase();

  // Si el modelo devuelve algo gen√©rico, afinamos con heur√≠stica
  const txt = String(originalText || '').toLowerCase();

  const has = (rx) => rx.test(txt);

  // Reglas por dispositivo
  if (device === 'teclado') {
    if (!k || /no_detecta|no reconoce|no funciona|no anda|no responde/.test(k) || has(/no (detecta|reconoce)|no (anda|funciona|responde)/))
      k = 'teclado_no_detecta';
  } else if (device === 'mouse') {
    if (!k || has(/no (detecta|reconoce)|no (anda|funciona|responde)/)) k = 'mouse_no_detecta';
  } else if (device === 'impresora') {
    if (!k || has(/no (detecta|reconoce)/)) k = 'impresora_no_detecta';
  } else if (device === 'almacenamiento') {
    if (!k || has(/(disco|ssd|hdd|pendrive|usb).*(no (detecta|reconoce|aparece))/))
      k = has(/(disco|ssd|hdd)/) ? 'disco_no_detecta' : 'usb_no_detecta';
  } else if (device === 'monitor') {
    if (!k && has(/(no (muestra|hay) (imagen|video)|sin imagen)/)) k = 'no_imagen';
  } else if (device === 'red') {
    if (!k && has(/(no (tengo|hay) internet|no conecta (el )?wifi|wifi no conecta)/)) k = has(/wifi/) ? 'wifi_no_conecta' : 'no_internet';
  } else if (device === 'camara') {
    if (!k || has(/no (detecta|reconoce)/)) k = 'camara_no_detecta';
  } else if (device === 'microfono') {
    if (!k || has(/no (detecta|reconoce)/)) k = 'microfono_no_detecta';
  }

  // Si sigue siendo algo fuera del set, devolvemos lo original o null
  if (!ISSUE_KEYS.includes(k)) return issueKey || null;
  return k;
}

function clamp01(n) {
  const x = Number(n);
  if (!isFinite(x)) return 0;
  return Math.max(0, Math.min(1, x));
}

async function analyzeProblemWithOA(problemText = '') {
  if (!openai) return { device: null, issueKey: null, confidence: 0 };

  const allowedDevices = CANON_DEVICES.join(', ');
  const allowedIssues  = ISSUE_KEYS.join(', ');

  const prompt = [
    'Sos t√©cnico inform√°tico argentino, claro y profesional.',
    'Analiz√° el texto del cliente y devolv√© SOLO un JSON con estas claves:',
    '  device: uno de [' + allowedDevices + ']',
    '  issueKey: uno de [' + allowedIssues + '] (eleg√≠ la m√°s espec√≠fica posible)',
    '  confidence: n√∫mero 0..1 seg√∫n tu seguridad',
    '',
    'Si el cliente habla de teclado/mouse/impresora/USB/pendrive y dice "no detecta/no reconoce/no funciona",',
    'tu issueKey debe ser la forma espec√≠fica: teclado_no_detecta, mouse_no_detecta, impresora_no_detecta, usb_no_detecta, etc.',
    '',
    `Texto del cliente: "${String(problemText).trim()}"`
  ].join('\n');

  try {
    const r = await openai.chat.completions.create({
      model: OPENAI_MODEL,
      messages: [{ role: 'user', content: prompt }],
      temperature: 0
    });

    // Limpieza por si el modelo devuelve en fences
    let raw = (r.choices?.[0]?.message?.content || '').trim();
    raw = raw.replace(/^\s*```json\s*|\s*```\s*$/g, '');
    const obj = JSON.parse(raw);

    // Normalizaci√≥n
    let dev = normalizeDevice(obj.device);
    let k   = String(obj.issueKey || '').toLowerCase();
    let conf = clamp01(obj.confidence);

    // Ajuste por texto si el device vino nulo pero el texto lo sugiere
    if (!dev) {
      dev = normalizeDevice(problemText);
    }

    // Afinado de issueKey espec√≠fico seg√∫n device + texto
    k = normalizeIssue(dev, k, problemText);

    return { device: dev || null, issueKey: k || null, confidence: conf };
  } catch (e) {
    console.error('[analyzeProblemWithOA+] ‚ùå', e.message);
    return { device: null, issueKey: null, confidence: 0 };
  }
}

// ===== OpenAI quick tests (opcional) =====
// Genera 4‚Äì6 pasos simples de diagn√≥stico b√°sico (o fallback est√°ndar)
async function aiQuickTests(problemText = '', device = '') {
  if (!openai) {
    // Fallback local si no hay API
    return [
      'Verificar conexi√≥n el√©ctrica/toma',
      'Probar con otro cable o cargador',
      'Mantener pulsado el bot√≥n de encendido 10 segundos',
      'Conectar directo (sin zapatillas/estabilizador)',
      'Comprobar si hay luces o sonidos al encender'
    ];
  }
  const prompt = [
    `Sos t√©cnico inform√°tico argentino, claro y amable.`,
    `Problema: "${problemText}"${device ? ` en ${device}` : ''}.`,
    `Indic√° 4‚Äì6 pasos simples y seguros.`,
    `Devolv√© solo un JSON array de strings.`
  ].join('\n');

  try {
    const resp = await openai.chat.completions.create({
      model: OPENAI_MODEL,
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.3
    });
    const raw = resp.choices?.[0]?.message?.content?.trim() || '[]';
    const jsonText = raw.replace(/```json|```/g, '').trim();
    const arr = JSON.parse(jsonText);
    return Array.isArray(arr) ? arr.filter(x => typeof x === 'string').slice(0, 6) : [];
  } catch (e) {
    console.error('[aiQuickTests] Error:', e.message);
    return ['Verificar cable/fuente', 'Probar otra toma', 'Forzar apagado/encendido', 'Probar otro cable/cargador', 'Chequear luces/sonidos al encender'];
  }
}

// ===== Endpoints =====

// Health: status del servicio y paths √∫tiles
app.get('/api/health', async (_req, res) => {
  res.json({
    ok: true,
    hasOpenAI: !!process.env.OPENAI_API_KEY,
    openaiReady: !!openai,
    openaiModel: OPENAI_MODEL || null,
    usingNewFlows: true,
    version: CHAT?.version || '4.8.3',
    paths: { data: DATA_BASE, transcripts: TRANSCRIPTS_DIR, tickets: TICKETS_DIR }
  });
});

// Reload chat config (GET/POST): vuelve a leer sti-chat.json sin reiniciar server
app.all('/api/reload', (_req, res) => {
  try { loadChat(); res.json({ ok: true, version: CHAT.version }); }
  catch (e) { res.status(500).json({ ok: false, error: e.message }); }
});

// Transcript plano: devuelve el .txt del historial de una sesi√≥n (debug/soporte)
app.get('/api/transcript/:sid', (req, res) => {
  const sid = String(req.params.sid || '').replace(/[^a-zA-Z0-9._-]/g, '');
  const file = path.join(TRANSCRIPTS_DIR, `${sid}.txt`);
  if (!fs.existsSync(file)) return res.status(404).json({ ok: false, error: 'not_found' });
  res.set('Content-Type', 'text/plain; charset=utf-8');
  res.send(fs.readFileSync(file, 'utf8'));
});

// WhatsApp ticket: genera ticket .txt + link p√∫blico + URL wa.me con texto prellenado
app.post('/api/whatsapp-ticket', async (req, res) => {
  try {
    const { name, device, sessionId, history = [] } = req.body || {};
    let transcript = history;
    const sid = sessionId || req.sessionId;

    // Si no mandan history expl√≠cito, intenta sacarlo de la sesi√≥n guardada
    if ((!transcript || transcript.length === 0) && sid) {
      const s = await getSession(sid);
      if (s?.transcript) transcript = s.transcript;
    }

    // ID legible: TCK-YYYYMMDD-XXXX
    const ymd = new Date().toISOString().slice(0,10).replace(/-/g,'');
    const rand = Math.random().toString(36).slice(2,6).toUpperCase();
    const ticketId = `TCK-${ymd}-${rand}`;

    // Render del contenido del ticket (simple texto)
    const lines = [];
    lines.push(`STI ‚Ä¢ Servicio T√©cnico Inteligente ‚Äî Ticket ${ticketId}`);
    lines.push(`Generado: ${nowIso()}`);
    if (name)   lines.push(`Cliente: ${name}`);
    if (device) lines.push(`Equipo: ${device}`);
    if (sid)    lines.push(`Session: ${sid}`);
    lines.push('');
    lines.push('=== HISTORIAL DE CONVERSACI√ìN ===');
    for (const m of transcript || []) {
      const who = m.who === 'user' ? 'USER' : 'ASSISTANT';
      lines.push(`[${m.ts || nowIso()}] ${who}: ${m.text || ''}`);
    }
    fs.writeFileSync(path.join(TICKETS_DIR, `${ticketId}.txt`), lines.join('\n'), 'utf8');

    // Construye link p√∫blico y texto para WhatsApp
    const publicUrl = `${PUBLIC_BASE_URL}/ticket/${ticketId}`;
    let waText = CHAT?.settings?.whatsapp_ticket?.prefix || 'Hola STI üëã. Vengo del chat web. Dejo mi consulta:';
    waText += '\n';
    if (name)   waText += `\nüë§ Cliente: ${name}\n`;
    if (device) waText += `üíª Equipo: ${device}\n`;
    waText += `\nüé´ Ticket: ${ticketId}\nüìÑ Detalle completo: ${publicUrl}`;

    const waUrl = `https://wa.me/${WHATSAPP_NUMBER}?text=${encodeURIComponent(waText)}`;
    res.json({ ok: true, ticketId, publicUrl, waUrl });
  } catch (e) {
    console.error('[whatsapp-ticket] ‚ùå', e);
    res.status(500).json({ ok: false, error: e.message });
  }
});

// P√°gina p√∫blica del ticket (HTML b√°sico con metadatos sociales)
app.get('/ticket/:id', (req, res) => {
  const id = String(req.params.id || '').replace(/[^A-Z0-9-]/g, '');
  const file = path.join(TICKETS_DIR, `${id}.txt`);
  if (!fs.existsSync(file)) return res.status(404).send('Ticket no encontrado');
  const content = fs.readFileSync(file, 'utf8');
  const title = `STI ‚Ä¢ Servicio T√©cnico Inteligente ‚Äî Ticket ${id}`;
  const desc = (content.split('\n').slice(0, 8).join(' ') || '').slice(0, 200);
  const url  = `${PUBLIC_BASE_URL}/ticket/${id}`;
  const logo = `${PUBLIC_BASE_URL}/logo.png`;

  res.set('Content-Type', 'text/html; charset=utf-8');
  res.send(`<!doctype html>
<html lang="es"><head>
<meta charset="utf-8"><title>${title}</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:type" content="article">
<meta property="og:title" content="${title}">
<meta property="og:description" content="${desc}">
<meta property="og:url" content="${url}">
<meta property="og:image" content="${logo}">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="${title}">
<meta name="twitter:description" content="${desc}">
<meta name="twitter:image" content="${logo}">
<style>
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif;margin:24px;background:#f5f5f5}
pre{white-space:pre-wrap;background:#0f172a;color:#e5e7eb;padding:16px;border-radius:12px;line-height:1.4;overflow:auto}
h1{font-size:20px;margin:0 0 6px}a{color:#2563eb;text-decoration:none}a:hover{text-decoration:underline}
</style></head>
<body>
<h1>${title}</h1>
<p><a href="https://stia.com.ar" target="_blank">stia.com.ar</a> ‚Ä¢ <a href="https://wa.me/${WHATSAPP_NUMBER}" target="_blank">WhatsApp</a></p>
<pre>${content.replace(/[&<>]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[s]))}</pre>
</body></html>`);
});

// Reset de sesi√≥n: √∫til para bot√≥n ‚ÄúNueva conversaci√≥n‚Äù en el front
app.post('/api/reset', async (req, res) => {
  const sid = req.sessionId;
  const empty = {
    id: sid, userName: null, stage: STATES.ASK_NAME,
    device:null, problem:null, issueKey:null,
    tests:{ basic:[], advanced:[], ai:[] }, stepsDone:[],
    fallbackCount:0, waEligible:false, transcript:[], pendingUtterance:null
  };
  await saveSession(sid, empty);
  res.json({ ok: true });
});

// ====== GREETING CON REINICIO FORZADO DE SESI√ìN ======
// Siempre arranca ‚Äúlimpio‚Äù: resetea sesi√≥n y devuelve el saludo con pedido de nombre
app.all('/api/greeting', async (req, res) => {
  try {
    const sid = req.sessionId;

    // Crea SIEMPRE una sesi√≥n fresca (evita estados pegados)
    const fresh = {
      id: sid,
      userName: null,
      stage: STATES.ASK_NAME,
      device: null,
      problem: null,
      issueKey: null,
      tests: { basic: [], advanced: [], ai: [] },
      stepsDone: [],
      fallbackCount: 0,
      waEligible: false,
      transcript: [],
      pendingUtterance: null
    };

    // Texto configurable desde JSON; fallback literal
    const text = CHAT?.messages_v4?.greeting?.name_request
      || 'üëã ¬°Hola! Soy Tecnos,  tu Asistente Inteligente. ¬øCu√°l es tu nombre?';

    fresh.transcript.push({ who: 'bot', text, ts: nowIso() });
    await saveSession(sid, fresh);

    return res.json({ ok: true, greeting: text, reply: text, options: [] });
  } catch (e) {
    console.error('[api/greeting RESET] error:', e);
    const text = 'üëã ¬°Hola! Soy Tecnos,  tu Asistente Inteligente. ¬øCu√°l es tu nombre?';
    return res.json({ ok: true, greeting: text, reply: text, options: [] });
  }
});

// Chat principal: coraz√≥n del flujo conversacional
app.post('/api/chat', async (req, res) => {
  try {
    const { text = '' } = req.body || {};
    const t = String(text).trim();
    const sid = req.sessionId;

    // Carga o crea sesi√≥n si no existe (primer mensaje)
    let session = await getSession(sid);
    if (!session) {
      session = {
        id: sid, userName: null, stage: STATES.ASK_NAME,
        device:null, problem:null, issueKey:null,
        tests:{ basic:[], advanced:[], ai:[] }, stepsDone:[],
        fallbackCount:0, waEligible:false, transcript:[], pendingUtterance:null
      };
      console.log(`[api/chat] ‚ú® Nueva sesi√≥n: ${sid}`);
    }

    // Log del usuario en transcript (memoria de la conversaci√≥n)
    session.transcript.push({ who: 'user', text: t, ts: nowIso() });

    // Detecci√≥n inline de nombre en el mismo mensaje (e.g., "hola, me llamo X")
    const nmInline = extractName(t);
    if (nmInline && !session.userName) {
      session.userName = cap(nmInline);
      if (session.stage === STATES.ASK_NAME) {
        session.stage = STATES.ASK_PROBLEM;
        const reply = `¬°Genial, ${session.userName}! üëç\n\nAhora decime: ¬øqu√© problema est√°s teniendo?`;
        session.transcript.push({ who: 'bot', text: reply, ts: nowIso() });
        await saveSession(sid, session);
        return res.json({ ok: true, reply, stage: session.stage, options: [] });
      }
    }

    let reply = ''; let options = [];

    // ===== 1) Estado: pedir nombre =====
    if (session.stage === STATES.ASK_NAME) {
      // Si describe problema antes del nombre, guardamos para retomarlo
      if (problemHint.test(t) && !extractName(t)) session.pendingUtterance = t;

      // Detecci√≥n de nombre u ‚Äúomitir‚Äù
      const name = extractName(t);
      if (/^omitir$/i.test(t)) {
        session.userName = session.userName || 'usuario';
      } else if (!session.userName && name) {
        session.userName = cap(name);
      }

      // Si a√∫n no tenemos nombre, re-preguntamos
      if (!session.userName) {
        reply = 'üòä ¬øC√≥mo te llam√°s?\n\n(Ejemplo: "soy Lucas")';
      } else {
        // Tenemos nombre ‚Üí pasamos a pedir problema
        session.stage = STATES.ASK_PROBLEM;
        if (session.pendingUtterance) {
          // Si ya hab√≠a contado el problema, lo retomamos y pedimos equipo
          session.problem = session.pendingUtterance;
          session.pendingUtterance = null;
          session.stage = STATES.ASK_DEVICE;
          options = ['PC','Notebook','Teclado','Mouse','Monitor','Internet / Wi-Fi'];
          reply = `Perfecto, ${session.userName}. Anot√©: ‚Äú${session.problem}‚Äù.\n\n¬øEn qu√© equipo te pasa?`;
        } else {
          reply = `¬°Genial, ${session.userName}! üëç\n\nAhora decime: ¬øqu√© problema est√°s teniendo?`;
        }
      }
    }

    // ===== 2) Estado: pedir problema (MEJORADO: prioriza OA en ambig√ºedad/perif√©ricos) =====
    else if (session.stage === STATES.ASK_PROBLEM) {
      session.problem = t || session.problem;

      try {
        // 1) Se√±ales de ambig√ºedad y menci√≥n de dispositivos/perif√©ricos
        const ambiguous = /(no (reconoce|detecta|anda|funciona|responde|enciende|arranca|inicia)|problema|error|falla)/i;
        const hasDeviceWord = /(teclado|keyboard|mouse|rat[o√≥]n|monitor|pantalla|impresora|printer|usb|pendrive|disco|ssd|hdd|c[a√°]mara|webcam|microf[o√≥]no|mic|wifi|wi-?fi|internet|red|ethernet|router|m[√≥o]dem|modem)/i;

        // 2) Inicializamos con detecci√≥n local m√≠nima
        let device     = detectDevice(session.problem);
        let issueKey   = detectIssue(session.problem);
        let confidence = issueKey ? 0.6 : 0;

        // 3) Si hay OpenAI y el texto es ambiguo o menciona perif√©ricos, priorizar OA
        if (openai && (ambiguous.test(session.problem) || hasDeviceWord.test(session.problem))) {
          const ai = await analyzeProblemWithOA(session.problem);
          if (ai.device)   device = ai.device;
          if (ai.issueKey) issueKey = ai.issueKey;
          confidence = Math.max(confidence, ai.confidence || 0);
        } else if (openai && (!issueKey || !device)) {
          // Si la regex local no fue concluyente, consult√° a OA igual como refuerzo
          const ai = await analyzeProblemWithOA(session.problem);
          if (ai.device && !device)   device = ai.device;
          if (ai.issueKey && !issueKey) issueKey = ai.issueKey;
          confidence = Math.max(confidence, ai.confidence || 0);
        }

        // 4) Si la confianza alcanza el umbral ‚Üí ir directo a pasos b√°sicos
        if (confidence >= OA_MIN_CONF && (issueKey || device)) {
          session.device   = session.device || device || 'equipo';
          session.issueKey = issueKey || session.issueKey || null;
          session.stage    = STATES.BASIC_TESTS;

          const key = session.issueKey || 'no_funciona';
          const stepsSrc = CHAT?.nlp?.advanced_steps?.[key];
          const steps = Array.isArray(stepsSrc) ? stepsSrc.slice(0, 4) : [
            'Verific√° la energ√≠a (enchufe / zapatilla / bot√≥n I/O de la fuente)',
            'Prob√° otro tomacorriente o cable/cargador',
            'Manten√© presionado el bot√≥n de encendido 15‚Äì30 segundos y prob√° de nuevo',
            'Si hay luces o sonidos, prob√° desconectar perif√©ricos y volver a encender'
          ];
          const stepsAr = mapVoseoSafe(steps);

          const intro = `Entiendo, ${session.userName}. Probemos esto primero:`;
          const footer = [
            '',
            'üß© ¬øSe solucion√≥?',
            'Si no, puedo ofrecerte algunas **pruebas m√°s avanzadas**.',
            '',
            'Decime: **"s√≠"**, **"no"** o **"avanzadas"**.'
          ].join('\n');

          session.tests.basic = stepsAr;
          session.stepsDone.push('basic_tests_shown');
          session.waEligible = true;

          const fullMsg = intro + '\n\n‚Ä¢ ' + stepsAr.join('\n‚Ä¢ ') + '\n' + footer;

          session.transcript.push({ who: 'bot', text: fullMsg, ts: nowIso() });
          await saveSession(sid, session);

          try {
            const tf = path.join(TRANSCRIPTS_DIR, `${sid}.txt`);
            fs.appendFileSync(tf, `[${nowIso()}] ASSISTANT: ${intro}\n`);
            stepsAr.forEach(s => fs.appendFileSync(tf, ` - ${s}\n`));
            fs.appendFileSync(tf, `\n${footer}\n`);
          } catch (e) { console.error('[transcript write] error:', e.message); }

          return res.json({
            ok: true,
            reply: fullMsg,
            steps,
            stepsType: 'basic',
            options: ['S√≠, se solucion√≥ ‚úÖ', 'No, sigue igual ‚ùå', 'Avanzadas üîß', 'WhatsApp'],
            stage: session.stage,
            allowWhatsapp: true
          });
        }

        // 5) Si no hay confianza suficiente ‚Üí pedimos equipo (sin perder el problema)
        session.stage = STATES.ASK_DEVICE;
        const msg = `Enseguida te ayudo con ese problema üîç\n\n` +
                    `Perfecto, ${session.userName}. Anot√©: ‚Äú${session.problem}‚Äù.\n\n` +
                    `¬øEn qu√© equipo te pasa? (PC, notebook, teclado, etc.)`;
        await saveSession(sid, session);
        return res.json({
          ok: true,
          reply: msg,
          options: ['PC','Notebook','Monitor','Teclado','Internet / Wi-Fi']
        });

      } catch (err) {
        console.error('diagn√≥stico ASK_PROBLEM+', err);
        return res.json({ ok: true, reply: 'Hubo un problema al procesar el diagn√≥stico. Prob√° de nuevo en un momento.' });
      }
    }

    // ===== 3) Estado: pedir equipo y derivar a tests =====
    else if (session.stage === STATES.ASK_DEVICE || !session.device) {
      // Usa regex o limpia texto (solo letras/espacios) para determinar el equipo
      const dev = detectDevice(t) || t.toLowerCase().replace(/[^a-z√°√©√≠√≥√∫√±\s]/gi, '').trim();
      if (dev && dev.length >= 2) {
        session.device = dev;

        // Intento de deducir issue combinando problema + equipo
        const issueKey = detectIssue(`${session.problem || ''} ${t}`.trim());
        if (issueKey) {
          // Tenemos issue ‚Üí pasos b√°sicos (3 primeros) + pie ¬øSe solucion√≥?
          session.issueKey = issueKey;
          session.stage    = STATES.BASIC_TESTS;
          const pasosSrc = CHAT?.nlp?.advanced_steps?.[issueKey];
          const pasos = Array.isArray(pasosSrc) ? pasosSrc : [
            'Reiniciar el equipo',
            'Verificar conexiones f√≠sicas',
            'Probar en modo seguro',
          ];
          const pasosAr = mapVoseoSafe(pasos);
          reply  = `Entiendo, ${session.userName}. Tu **${session.device}** tiene el problema: ${issueHuman(issueKey)} üîç\n\n`;
          reply += `üîß **Prob√° estos pasos b√°sicos:**\n\n`;
          pasosAr.slice(0, 3).forEach((p, i) => { reply += `${i + 1}. ${p}\n`; });

          // Pie unificado
          reply += `\nüß© ¬øSe solucion√≥?\n`;
          reply += `Si no, puedo ofrecerte algunas **pruebas m√°s avanzadas**.\n\n`;
          reply += `Decime: **"s√≠"** o **"no"**.\n`;

          session.tests.basic = pasosAr.slice(0, 3);
          session.stepsDone.push('basic_tests_shown');
          options = ['S√≠, se solucion√≥ ‚úÖ','No, sigue igual ‚ùå','Avanzadas üîß','WhatsApp'];
          session.waEligible = true;
        } else {
          // No hay issue claro ‚Üí pedir AI quick tests + pie ¬øSe solucion√≥?
          session.stage = STATES.BASIC_TESTS_AI;
          try {
            const ai = await aiQuickTests(session.problem || '', session.device || '');
            if (ai.length) {
              const aiAr = mapVoseoSafe(ai);
              reply  = `Entiendo, ${session.userName}. Probemos esto r√°pido üîç\n\n`;
              reply += `üîß **Pasos iniciales:**\n\n`;
              aiAr.forEach(s => reply += `‚Ä¢ ${s}\n`);

              // Pie unificado
              reply += `\nüß© ¬øSe solucion√≥?\n`;
              reply += `Si no, puedo ofrecerte algunas **pruebas m√°s avanzadas**.\n\n`;
              reply += `Decime: **"s√≠"**, **"no"** o **"avanzadas"**.\n`;

              session.tests.ai = aiAr;
              session.stepsDone.push('ai_basic_shown');
              session.waEligible = true;
              options = ['S√≠, se solucion√≥ ‚úÖ','No, sigue igual ‚ùå','Avanzadas üîß','WhatsApp'];
            } else {
              reply = `Perfecto, ${session.userName}. Anotado: **${session.device}** üìù\n\nContame un poco m√°s del problema.`;
            }
          } catch (e) {
            console.error('[aiQuickTests] ‚ùå', e.message);
            reply = 'No pude generar sugerencias ahora üòÖ. Contame un poco m√°s del problema.';
          }
        }
      } else {
        // Si no reconoce el equipo, ofrece opciones clicables
        reply = '¬øPod√©s decirme el tipo de equipo?\n\n(Ejemplo: PC, notebook, monitor, teclado, etc.)';
        options = ['PC','Notebook','Monitor','Teclado','Mouse','Internet / Wi-Fi'];
      }
    }

    // ===== 4) Estados de pruebas y escalaci√≥n =====
    else {
      // --- NUEVO: manejo expl√≠cito de "s√≠ / no / avanzadas" luego del pie ---
      const rxYes = /\b(s[i√≠]|s√≠ se solucion[o√≥]|se solucion[o√≥]|funcion[o√≥]|ya anda|listo funcion[o√≥])\b/i;
      const rxNo  = /\b(no|todav[i√≠]a no|no funcion[o√≥]|sigue igual|no cambi[o√≥]|tampoco)\b/i;
      const rxAdv = /\b(avanzadas?|m[a√°]s pruebas|pruebas t[e√©]cnicas|continuar|seguir)\b/i;

      if (rxYes.test(t)) {
        // Cierre amable + CTA WhatsApp seg√∫n texto acordado
        reply  = `¬°Excelente, ${session.userName}! üôå\n`;
        reply += `Me alegra que se haya solucionado üí™\n`;
        reply += `Si vuelve a ocurrir o necesit√°s revisar otro equipo, pod√©s contactarnos nuevamente cuando quieras.\n\n`;
        reply += `¬°Gracias por confiar en STI! ‚ö°\n\n`;
        reply += `Si quer√©s hacerle alg√∫n comentario al cuerpo t√©cnico, puls√° el bot√≥n verde y se enviar√° un ticket por WhatsApp con esta conversaci√≥n.\n`;
        reply += `Envi√° el mensaje sin modificarlo, y luego pod√©s hacer el comentario que quieras. üì®`;
        options = ['WhatsApp'];
        session.stage = STATES.ESCALATE;     // marcamos fin del flujo autom√°tico
        session.waEligible = true;

      } else if (rxNo.test(t)) {
        session.stepsDone.push('user_says_not_working');
        const triedAdv = (session.stage === STATES.ADVANCED_TESTS);
        const noCount = session.stepsDone.filter(x => x === 'user_says_not_working').length;
        const adv = (CHAT?.nlp?.advanced_steps?.[session.issueKey] || []).slice(3, 6);
        const advAr = mapVoseoSafe(adv);
        if (triedAdv || noCount >= 2 || advAr.length === 0) {
          session.stage = STATES.ESCALATE;
          session.waEligible = true;
          reply = 'Entiendo. Te paso con un t√©cnico para ayudarte personalmente. Toc√° el bot√≥n verde y se enviar√° un ticket con esta conversaci√≥n para agilizar la atenci√≥n.';
          options = ['WhatsApp'];
        } else {
          session.stage = STATES.ADVANCED_TESTS;
          session.tests.advanced = advAr;
          reply = `Entiendo, ${session.userName} üòî\nEntonces vamos a hacer unas **pruebas m√°s avanzadas** para tratar de solucionarlo. üîç\n\n`;
          advAr.forEach((p, i) => reply += `${i + 1}. ${p}\n`);
          session.waEligible = true;
          options = ['Volver a b√°sicas','WhatsApp'];
        }
      } else if (rxAdv.test(t)) {
        // Ir directo a avanzadas sin repetir el discurso
        const adv = (CHAT?.nlp?.advanced_steps?.[session.issueKey] || []).slice(3, 6);
        const advAr = mapVoseoSafe(adv);
        if (advAr.length > 0) {
          session.stage = STATES.ADVANCED_TESTS;
          session.tests.advanced = advAr;
          reply  = `Perfecto üëç\n`;
          reply += `Te muestro las **pruebas m√°s avanzadas** para este caso:\n\n`;
          advAr.forEach((p, i) => reply += `${i + 1}. ${p}\n`);
          session.waEligible = true;
          options = ['Volver a b√°sicas','WhatsApp'];
        } else {
          reply = 'No tengo m√°s pasos autom√°ticos para este caso. Te paso con un t√©cnico para seguimiento por WhatsApp.';
          session.waEligible = true; options = ['WhatsApp'];
          session.stage = STATES.ESCALATE;
        }

      // Petici√≥n directa de derivaci√≥n a humano/WhatsApp (atajo)
      } else if (/\b(whatsapp|t[√©e]cnico|derivar|persona|humano)\b/i.test(t)) {
        session.waEligible = true;
        reply = '‚úÖ Te preparo un ticket con el historial para WhatsApp.';
        options = ['Enviar a WhatsApp (con ticket)'];

      // Confirmaci√≥n gen√©rica ‚Äúok/dale/listo/prob√©‚Äù ‚Üí intenta avanzar a avanzadas si corresponde
      } else if (/\b(dale|ok|bueno|joya|b[√°a]rbaro|listo|perfecto|prob[√©e]|hice)\b/i.test(t)) {
        session.stepsDone.push('user_confirmed_basic');
        if (session.stage === STATES.BASIC_TESTS && ((session.tests.basic || []).length >= 2 || (session.tests.ai || []).length >= 2)) {
          const adv = (CHAT?.nlp?.advanced_steps?.[session.issueKey] || []).slice(3, 6);
          const advAr = mapVoseoSafe(adv);
          if (advAr.length > 0) {
            session.stage = STATES.ADVANCED_TESTS;
            session.tests.advanced = advAr;
            reply = `Genial, ${session.userName}. Sigamos con pasos m√°s avanzados üîß\n\n`;
            advAr.forEach((p, i) => reply += `${i + 1}. ${p}\n`);
            reply += `\n¬øPudiste probar alguno?`;
            session.waEligible = true;
            options = ['Volver a b√°sicas','WhatsApp'];
          } else {
            reply = 'üëç Perfecto. Si persiste, te paso con un t√©cnico.';
            session.waEligible = true;
            options = ['WhatsApp'];
          }
        } else {
          reply = 'üëç Perfecto. ¬øAlguno de esos pasos ayud√≥?';
          options = ['Pasar a avanzadas','WhatsApp'];
        }

      // Mensaje gen√©rico de loop cuando espera acci√≥n del usuario
      } else {
        reply = `Record√° que estamos revisando tu **${session.device || 'equipo'}** por ${issueHuman(session.issueKey)} üîç\n\n` +
                `¬øProbaste los pasos que te suger√≠?\n\n` +
                'Decime:\n‚Ä¢ **"s√≠"** si los probaste\n‚Ä¢ **"no"** si no funcionaron\n‚Ä¢ **"avanzadas"** para ver m√°s pruebas\n‚Ä¢ **"ayuda"** para hablar con un t√©cnico';
        options = ['Avanzadas üîß','WhatsApp'];
      }
    }

    // Persistencia del mensaje del bot
    session.transcript.push({ who: 'bot', text: reply, ts: nowIso() });
    await saveSession(sid, session);

    // Adem√°s, guarda en archivo .txt para auditor√≠a
    try {
      const tf = path.join(TRANSCRIPTS_DIR, `${sid}.txt`);
      fs.appendFileSync(tf, `[${nowIso()}] USER: ${t}\n`);
      fs.appendFileSync(tf,  `[${nowIso()}] ASSISTANT: ${reply}\n`);
    } catch (e) { console.warn('[transcript] no pude escribir:', e.message); }

    // Arma respuesta HTTP (incluye options y flag allowWhatsapp si aplica)
    const response = withOptions({ ok: true, reply, sid, stage: session.stage });
    if (options && options.length) response.options = options;
    if (session.waEligible) response.allowWhatsapp = true;
    return res.json(response);

  } catch (e) {
    console.error('[api/chat] ‚ùå Error:', e);
    return res.status(200).json(withOptions({ ok: true, reply: 'üòÖ Tuve un problema moment√°neo. Prob√° de nuevo.' }));
  }
});

// Listar sesiones activas (debug/admin)
app.get('/api/sessions', async (_req, res) => {
  const sessions = await listActiveSessions();
  res.json({ ok: true, count: sessions.length, sessions });
});

// ===== Server =====
const PORT = process.env.PORT || 3001;     // Puerto (Render suele inyectar PORT)
app.listen(PORT, () => {
  console.log('\n' + '='.repeat(60));
  console.log(`üöÄ [STI Chat V4.8.3-FlowFix] Started`);
  console.log(`üìç Port: ${PORT}`);
  console.log(`üìÇ Data: ${DATA_BASE}`);
  console.log(`${CHAT?.version ? `üìã Chat config: ${CHAT.version}` : '‚ö†Ô∏è  No chat config loaded'}`);
  console.log('='.repeat(60) + '\n');
});

</p>




  </div>
</body>
</html>
