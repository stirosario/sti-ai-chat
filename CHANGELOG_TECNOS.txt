REGISTRO √öNICO DE CAMBIOS - CHATBOT TECNOS
===========================================
Fecha inicio: 2025-12-24
Objetivo: Auditar y mejorar el ChatBot Tecnos con foco en coherencia del flujo conversacional, memoria de sesi√≥n y observabilidad.

UBICACI√ìN: C:\sti-ai-chat\CHANGELOG_TECNOS.txt

===========================================
ENTRADAS DE CAMBIOS
===========================================

------------------------------------------------------------
ID CAMBIO: CHG-20251224-001
ETAPA: 1.A
ARCHIVO(S): C:\sti-ai-chat\server.js
MOTIVO:
- El endpoint /api/chat no garantizaba un contrato estable de respuesta con todos los campos requeridos (conversation_id, session_id, correlation_id, message_id, parent_message_id, stage, actor, text, buttons[], latency_ms, error_code).
- Las respuestas pod√≠an faltar campos cr√≠ticos para observabilidad y trazabilidad.
- No hab√≠a logs estructurados JSON por turno para an√°lisis posterior.
- El lastBotMessageId solo se actualizaba para respuestas con botones, no para todas las respuestas del bot.

ANTES (snippet):
<<<
// Helper para retornar y loggear autom√°ticamente
const logAndReturn = async (response, stage, nextStage, trigger = 'N/A', action = 'response_sent', sessionParam = null) => {
  // ...
  return res.json(response); // Respuesta sin normalizaci√≥n
};

// A4: Solo actualizaba lastBotMessageId si hab√≠a botones
if ((who === 'bot' || who === 'assistant') && finalButtons && Array.isArray(finalButtons) && finalButtons.length > 0) {
  session.lastBotMessageId = message_id;
  // ...
}
>>>

DESPU√âS (snippet):
<<<
// ETAPA 1.A: Helper para normalizar respuesta del endpoint /api/chat
function normalizeChatResponse(response, session, correlationId, latencyMs, clientMessageId = null, parentMessageId = null) {
  // Garantiza campos: conversation_id, session_id, correlation_id, message_id, parent_message_id, stage, actor, text, buttons[], latency_ms, error_code
  // ...
}

// Helper para retornar y loggear autom√°ticamente
const logAndReturn = async (response, stage, nextStage, trigger = 'N/A', action = 'response_sent', sessionParam = null) => {
  // ...
  const normalizedResponse = normalizeChatResponse(/* ... */);
  // Log estructurado JSON por turno
  console.log(JSON.stringify({
    event: 'CHAT_TURN',
    correlation_id: correlationId,
    conversation_id: currentSession?.conversationId || null,
    // ... todos los campos con PII enmascarado
  }));
  return res.json(normalizedResponse);
};

// ETAPA 1.A: Actualizar lastBotMessageId para TODAS las respuestas del bot
if (who === 'bot' || who === 'assistant') {
  session.lastBotMessageId = message_id;
  // ...
}
>>>

IMPACTO ESPERADO:
- Todas las respuestas de /api/chat ahora incluyen el contrato completo de campos requeridos.
- Logs estructurados JSON por turno (una l√≠nea por evento) con PII enmascarado para an√°lisis.
- lastBotMessageId se actualiza para TODAS las respuestas del bot (no solo con botones).
- Mejora la observabilidad y trazabilidad de las conversaciones.

PRUEBA R√ÅPIDA DE VERIFICACI√ìN:
- Paso 1: Enviar un mensaje al endpoint /api/chat
- Paso 2: Verificar en la respuesta JSON que incluye: conversation_id, session_id, correlation_id, message_id, parent_message_id, stage, actor, text, buttons, latency_ms
- Paso 3: Verificar en los logs del servidor que se emite una l√≠nea JSON con event="CHAT_TURN"
- Resultado esperado: Respuesta normalizada con todos los campos y log estructurado visible

NOTAS:
- La funci√≥n normalizeChatResponse est√° disponible para ser usada en todos los lugares donde se retorna una respuesta.
- Pendiente: Actualizar otros lugares donde se retorna res.json() directamente (se har√° en siguientes cambios incrementales).

------------------------------------------------------------
ID CAMBIO: CHG-20251224-002
ETAPA: 1.D (P0-FIX)
ARCHIVO(S): C:\sti-ai-chat\server.js
MOTIVO:
- Fix cr√≠tico: el chat se quedaba en "TECNOS... (pensando)" porque las llamadas a OpenAI no ten√≠an timeout REAL.
- El AbortController se creaba pero el signal no se pasaba correctamente al SDK (se pasaba dentro de params en lugar de como segundo par√°metro de opciones).
- El timeout de 30s empataba con el timeout del frontend (30s), causando que el usuario viera "pensando" indefinidamente.
- No hab√≠a un hard timeout a nivel de request del endpoint /api/chat.

ANTES (snippet):
<<<
// AbortController decorativo que no funciona
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 30000);
const r = await openai.chat.completions.create({
  model: OPENAI_MODEL,
  messages: [...],
  temperature: 0,
  signal: controller.signal // ‚ùå INCORRECTO: signal dentro de params
});
clearTimeout(timeoutId);
>>>

DESPU√âS (snippet):
<<<
// Wrapper √∫nico con timeout REAL
async function callOpenAIWithTimeout(params, options = {}) {
  const { timeoutMs = 15000, correlationId, stage, label } = options;
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    // ‚úÖ CORRECTO: signal como segundo par√°metro (opciones de request)
    const response = await openai.chat.completions.create(params, {
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    // Logs estructurados: AI_CALL_START, AI_CALL_END, AI_CALL_TIMEOUT
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    // Manejo de timeout y errores...
  }
}

// Uso en funciones:
const r = await callOpenAIWithTimeout({
  model: OPENAI_MODEL,
  messages: [...],
  temperature: 0
}, {
  timeoutMs: 12000, // < 30s para no empatar frontend
  correlationId: session?.correlationId,
  stage: session?.stage,
  label: 'aiQuickTests'
});

// Hard timeout en /api/chat (25s)
const HARD_TIMEOUT_MS = 25000;
const hardTimeout = setTimeout(() => {
  if (!hasResponded && !res.headersSent) {
    // Responder con mensaje seguro + botones
  }
}, HARD_TIMEOUT_MS);

// Garant√≠a "siempre se responde" al final del try
if (!hasResponded && !res.headersSent) {
  // Responder con mensaje seguro
}
>>>

IMPACTO ESPERADO:
- Todas las llamadas a OpenAI ahora tienen timeout REAL que funciona correctamente.
- Timeouts configurados < 30s (12s para quick tests, 15-18s para an√°lisis) para evitar empatar con frontend.
- Hard timeout de 25s en /api/chat garantiza que el request siempre responda antes del timeout del frontend.
- Logs estructurados (AI_CALL_START, AI_CALL_END, AI_CALL_TIMEOUT) para observabilidad.
- Garant√≠a de respuesta: si ninguna rama retorna, se env√≠a respuesta segura antes de salir del handler.

PRUEBA R√ÅPIDA DE VERIFICACI√ìN:
- Paso 1: Enviar mensaje que active an√°lisis de OpenAI (ej: problema complejo)
- Paso 2: Verificar que responde antes de 25s (idealmente < 5s si no usa IA)
- Paso 3: Simular OpenAI lento (deshabilitar API key o timeout artificial) - debe responder con fallback
- Paso 4: Verificar en logs que aparecen eventos AI_CALL_START/END/TIMEOUT con correlation_id
- Resultado esperado: Chat nunca se queda en "pensando", siempre responde con mensaje √∫til

NOTAS:
- Todos los timeouts configurados: 12s (quick tests), 15s (an√°lisis/explicaciones), 18s (an√°lisis con im√°genes).
- Hard timeout de 25s es < 30s del frontend, dejando margen para respuesta.
- Wrapper √∫nico centraliza l√≥gica de timeout y logging.

------------------------------------------------------------
ID CAMBIO: CHG-20251224-003
ETAPA: 1.D (P0-FIX)
ARCHIVO(S): C:\sti-ai-chat\server.js
MOTIVO:
- Bug cr√≠tico: cuando el usuario ESCRIBE texto en stage=ASK_NAME (ej: "Pablo"), el backend no enruta al handler ASK_NAME y cae en fallback NO_RESPONSE_PATH.
- El handler de ASK_NAME estaba ubicado despu√©s de otras l√≥gicas, causando que el request llegara al fallback antes de ejecutar el handler.
- El handler antiguo usaba res.json() directamente sin normalizeChatResponse ni logs estructurados.
- No hab√≠a logs de diagn√≥stico para rastrear el flujo de enrutado por stage.

ANTES (snippet):
<<<
// Handler ASK_NAME ubicado despu√©s de otras l√≥gicas (l√≠nea ~8545)
// ... c√≥digo que puede hacer return antes ...
if (session.stage === STATES.ASK_NAME) {
  // ... handler antiguo ...
  return res.json(response); // Sin normalizaci√≥n, sin logs estructurados
}

// M√°s abajo: fallback NO_RESPONSE_PATH
if (!hasResponded && !res.headersSent) {
  // Retorna fallback "Estoy tardando..."
}
>>>

DESPU√âS (snippet):
<<<
// ETAPA 1.D (P0-FIX): STAGE ROUTER EXPL√çCITO - ANTES de cualquier otra l√≥gica (l√≠nea ~7696)
console.log(`[ROUTER] enter stage=${session.stage} action=${action} msgLen=${effectiveText?.length || 0} hasButton=${!!buttonToken}`);

// ASK_NAME: Procesar texto o bot√≥n para recolecci√≥n de nombre
if (session.stage === STATES.ASK_NAME) {
  console.log(`[ROUTER] handling ASK_NAME - action=${action} hasButton=${!!buttonToken} textLen=${effectiveText?.length || 0}`);
  
  // Procesar TEXTO para nombre (solo si no es bot√≥n)
  if (!buttonToken && (action === 'message' || action === 'text') && effectiveText && effectiveText.trim().length > 0) {
    const nameText = effectiveText.trim();
    // ... validaci√≥n y procesamiento ...
    
    // Nombre v√°lido - transici√≥n a ASK_PROBLEM
    session.userName = candidate;
    await setStage(session, STATES.ASK_PROBLEM, 'ASK_NAME_completed', { session_id: sid });
    
    const response = normalizeChatResponse({
      ok: true,
      reply,
      stage: session.stage,
      options: [],
      buttons: []
    }, session, correlationId, latencyMs, clientMessageId, null);
    
    const logTurn = {
      event: 'CHAT_TURN',
      timestamp_iso: new Date().toISOString(),
      correlation_id: correlationId,
      // ... todos los campos ...
    };
    console.log(JSON.stringify(logTurn));
    console.log(`[ROUTER] handled ASK_NAME_TEXT ok userName=${candidate} nextStage=ASK_PROBLEM`);
    
    clearHardTimeout();
    return res.json(response); // ‚úÖ SIEMPRE retorna aqu√≠
  }
}

// Firma de build al iniciar servidor
const BUILD_TAG = process.env.BUILD_TAG || 'local-dev';
const BUILD_COMMIT = process.env.BUILD_COMMIT || process.env.HEROKU_SLUG_COMMIT || 'unknown';
console.log(`[BUILD_INFO] STI Chat (v7) - BUILD_TAG: ${BUILD_TAG} - COMMIT: ${BUILD_COMMIT.substring(0, 8)}`);
>>>

IMPACTO ESPERADO:
- El handler de ASK_NAME ahora se ejecuta ANTES de cualquier otra l√≥gica, garantizando que los requests con stage=ASK_NAME se procesen correctamente.
- Los logs [ROUTER] permiten diagnosticar el flujo de enrutado por stage.
- Las respuestas usan normalizeChatResponse para contrato consistente y logs estructurados.
- La firma de build permite verificar que se est√° ejecutando el archivo correcto en producci√≥n.
- El handler antiguo fue deshabilitado (comentado) para evitar duplicaci√≥n.

PRUEBA R√ÅPIDA DE VERIFICACI√ìN:
- Paso 1: Consent YES -> Language ES -> En ASK_NAME escribir "Pablo"
- Resultado esperado: respuesta 200, stage=ASK_PROBLEM, reply pregunta problema, SIN fallback "Estoy tardando‚Ä¶"
- Paso 2: ASK_NAME con bot√≥n "Prefiero no decirlo"
- Resultado esperado: stage=ASK_PROBLEM ok
- Paso 3: Verificar logs del servidor para ver [ROUTER] enter stage=ASK_NAME y [ROUTER] handled ASK_NAME_TEXT ok
- Paso 4: Verificar BUILD_INFO en logs al iniciar servidor para confirmar archivo correcto

NOTAS:
- El handler antiguo de ASK_NAME (l√≠nea ~8771) fue comentado para evitar ejecuci√≥n duplicada.
- La firma de build se imprime al iniciar el servidor para verificar que se ejecuta el archivo correcto en Render/producci√≥n.
- El nuevo handler est√° ubicado justo despu√©s de persistir el mensaje del usuario y antes del router de botones.
- Los timeouts de OpenAI ya est√°n correctamente implementados (ver CHG-20251224-002).

------------------------------------------------------------
ID CAMBIO: CHG-20251224-004
ETAPA: 1.D (P0-FIX)
ARCHIVO(S): C:\sti-ai-chat\server.js
MOTIVO:
- Bug cr√≠tico: cuando el usuario ESCRIBE texto en stage=ASK_PROBLEM (ej: "mi pc no enciende"), el backend no ejecuta el handler ASK_PROBLEM y cae en fallback NO_RESPONSE_PATH.
- BTN_RETRY estaba siendo tratado como problema: session.problem = "BTN_RETRY" (incorrecto).
- El handler existente de ASK_PROBLEM (l√≠nea ~9147) no se ejecutaba cuando llegaba texto porque el c√≥digo llegaba al fallback antes.

ANTES (snippet):
<<<
// No hab√≠a handler espec√≠fico para ASK_PROBLEM + texto en el stage router
// El c√≥digo llegaba al handler existente (l√≠nea ~9147) pero solo si session.problem ya estaba seteado
// Si llegaba texto nuevo, no se procesaba y ca√≠a en fallback NO_RESPONSE_PATH

// BTN_RETRY no ten√≠a manejo especial, pod√≠a llegar al handler de ASK_PROBLEM como texto
if (session.stage === STATES.ASK_PROBLEM) {
  session.problem = effectiveText || session.problem; // ‚ùå BTN_RETRY se convert√≠a en problema
  // ...
}
>>>

DESPU√âS (snippet):
<<<
// ETAPA 1.D (P0-FIX): Handler ASK_PROBLEM_TEXT en stage router (l√≠nea ~7922)
if (session.stage === STATES.ASK_PROBLEM && !buttonToken && (action === 'message' || action === 'text') && effectiveText && effectiveText.trim().length > 0) {
  console.log(`[ROUTER] handling ASK_PROBLEM_TEXT - action=${action} textLen=${effectiveText.trim().length}`);
  
  const problemTextRaw = effectiveText.trim();
  session.problemTextRaw = problemTextRaw;
  
  console.log(`[ROUTER] ASK_PROBLEM_TEXT processed - problemTextRaw="${problemTextRaw.substring(0, 50)}" - continuing to ASK_PROBLEM handler`);
  // NO hacer return - dejar que contin√∫e al handler existente de ASK_PROBLEM
}

// BTN_RETRY: Manejo especial antes del router de botones (l√≠nea ~7954)
if (buttonToken === 'BTN_RETRY' && session.stage === STATES.ASK_PROBLEM) {
  console.log(`[ROUTER] handling BTN_RETRY in ASK_PROBLEM - resetting problem`);
  
  // Resetear solo lo necesario, NO tocar userName
  session.problem = null;
  session.problemTextRaw = null;
  session.issueKey = null;
  session.tests = { basic: [], ai: [], advanced: [] };
  session.lastHelpStep = null;
  
  await saveSession(sid, session);
  
  const reply = isEn
    ? `Let's try again, ${whoName}! üëç\n\nTell me in a sentence: what's the main problem?`
    : `¬°Intentemos nuevamente, ${whoName}! üëç\n\nContame en una frase: ¬øcu√°l es el problema principal?`;
  
  const response = normalizeChatResponse({ ok: true, reply, stage: session.stage, options: [], buttons: [] }, ...);
  console.log(`[ROUTER] handled BTN_RETRY ok nextStage=ASK_PROBLEM`);
  
  clearHardTimeout();
  return res.json(response); // ‚úÖ Return para evitar que contin√∫e el flujo
}
>>>

IMPACTO ESPERADO:
- El handler de ASK_PROBLEM_TEXT ahora captura texto en ASK_PROBLEM ANTES del router de botones, permitiendo que el handler existente se ejecute correctamente.
- BTN_RETRY ya no se trata como problema, resetea correctamente y mantiene stage=ASK_PROBLEM.
- Los logs [ROUTER] permiten diagnosticar el flujo de enrutado por stage.
- Las respuestas usan normalizeChatResponse para contrato consistente y logs estructurados.
- El fallback NO_RESPONSE_PATH solo se activa en casos reales de timeout o errores inesperados.

PRUEBA R√ÅPIDA DE VERIFICACI√ìN:
- Paso 1: Consent YES -> Language ES -> Nombre "Luciano" -> ASK_PROBLEM -> escribir "mi pc no enciende"
- Resultado esperado: respuesta 200, ok:true, reply NO gen√©rico, NO aparece CHAT_REQ_NO_RESPONSE ni error_code NO_RESPONSE_PATH, el flujo contin√∫a (quick tests / diagn√≥stico / pedir detalle)
- Paso 2: En ASK_PROBLEM presionar bot√≥n "Reintentar" (BTN_RETRY)
- Resultado esperado: NO se ejecuta an√°lisis con "problem=BTN_RETRY", se re-pregunta el problema, stage=ASK_PROBLEM se mantiene
- Paso 3: Verificar logs del servidor para ver [ROUTER] handling ASK_PROBLEM_TEXT y [ROUTER] handled ASK_PROBLEM_TEXT ok (cuando corresponda)
- Paso 4: Verificar que NO aparece CHAT_REQ_NO_RESPONSE en estos casos normales

NOTAS:
- El handler de ASK_PROBLEM_TEXT NO hace return, permitiendo que el c√≥digo contin√∫e al handler existente de ASK_PROBLEM (l√≠nea ~9147) que procesa el problema correctamente.
- El handler existente hace: session.problem = effectiveText || session.problem, as√≠ que effectiveText se procesa correctamente.
- BTN_RETRY tiene manejo especial que resetea el problema y hace return para evitar que contin√∫e el flujo.
- El fallback NO_RESPONSE_PATH se mantiene como √∫ltimo recurso para casos de timeout real o errores inesperados.

------------------------------------------------------------
ID CAMBIO: CHG-20251225-001
ETAPA: 1.D (P0-FIX)
ARCHIVO(S): C:\sti-ai-chat\server.js
MOTIVO:
- Bug cr√≠tico: cuando el usuario ESCRIBE texto en stage=ASK_PROBLEM, el stage router loguea "continuing to ASK_PROBLEM handler" pero el request termina en fallback NO_RESPONSE_PATH en ~200ms.
- El handler de ASK_PROBLEM_TEXT no hac√≠a return expl√≠cito, permitiendo que el c√≥digo continuara pero luego ca√≠a en el fallback.
- Necesidad de guardrail espec√≠fico para ASK_PROBLEM antes del fallback gen√©rico para evitar que el usuario vea "Estoy tardando..." en casos normales.

ANTES (snippet):
<<<
// ASK_PROBLEM_TEXT solo seteaba problemTextRaw y continuaba
if (session.stage === STATES.ASK_PROBLEM && !buttonToken && ...) {
  session.problemTextRaw = problemTextRaw;
  // NO setear session.problem
  // NO hacer return - dejar que contin√∫e
  console.log(`... continuing to ASK_PROBLEM handler`);
}
// ... c√≥digo contin√∫a ...
// Fallback NO_RESPONSE_PATH (l√≠nea ~10334)
if (!hasResponded && !res.headersSent) {
  // Retorna "Estoy tardando m√°s de lo normal..."
}
>>>

DESPU√âS (snippet):
<<<
// ASK_PROBLEM_TEXT setea session.problem y limpia state de retry
if (session.stage === STATES.ASK_PROBLEM && !buttonToken && (action === 'message' || action === 'text') && effectiveText?.trim()) {
  console.log(`[ROUTER] handling ASK_PROBLEM_TEXT - action=${action} textLen=${effectiveText.trim().length}`);
  
  const problemTextRaw = effectiveText.trim();
  session.problemTextRaw = problemTextRaw;
  session.problem = problemTextRaw; // CLAVE: el handler legacy suele depender de session.problem
  
  // Limpiar state de retry si exist√≠a
  session.issueKey = null;
  session.tests = session.tests || { basic: [], ai: [], advanced: [] };
  session.lastHelpStep = null;
  
  await saveSession(sid, session);
  console.log(`[ROUTER] ASK_PROBLEM_TEXT set - invoking ASK_PROBLEM handler`);
  // NO hacer return - el handler existente de ASK_PROBLEM se ejecutar√° despu√©s
}

// Guardrail anti NO_RESPONSE_PATH para ASK_PROBLEM (l√≠nea ~10335)
if (!hasResponded && !res.headersSent) {
  if (session?.stage === STATES.ASK_PROBLEM) {
    console.warn(`[ROUTER] UNHANDLED ASK_PROBLEM PATH - forcing safe reply`);
    const reply = isEn
      ? `Tell me the main problem in one sentence (PC / notebook / Wi-Fi / printer / account).`
      : `Decime el problema principal en 1 frase (PC / notebook / Wi-Fi / impresora / cuenta).`;
    const response = normalizeChatResponse({ ok:true, reply, stage: session.stage, options: [], buttons: [] }, ...);
    clearHardTimeout();
    return res.json(response); // ‚úÖ Return expl√≠cito antes del fallback gen√©rico
  }
  // ... fallback gen√©rico "Estoy tardando..."
}
>>>

IMPACTO ESPERADO:
- El handler de ASK_PROBLEM_TEXT ahora setea session.problem correctamente, permitiendo que el handler existente lo procese.
- El guardrail espec√≠fico para ASK_PROBLEM evita que el usuario vea el fallback gen√©rico "Estoy tardando..." en casos normales.
- BTN_RETRY ya estaba bien manejado (reset correcto, no setea session.problem="BTN_RETRY").
- Los logs [ROUTER] permiten diagnosticar el flujo de enrutado.
- El fallback gen√©rico NO_RESPONSE_PATH solo se activa para stages distintos de ASK_PROBLEM.

PRUEBA R√ÅPIDA DE VERIFICACI√ìN:
- Caso A (texto): Consent YES -> Lang ES -> Nombre "Lautaro" -> ASK_PROBLEM -> escribir "mi notebook no enciende"
  - Resultado esperado: NO aparece error_code=NO_RESPONSE_PATH, logs incluyen [ROUTER] handling ASK_PROBLEM_TEXT, respuesta NO gen√©rica, inicia diagn√≥stico
- Caso B (retry): En ASK_PROBLEM presionar BTN_RETRY
  - Resultado esperado: NO se setea session.problem="BTN_RETRY", responde re-preguntando el problema, stage sigue ASK_PROBLEM
- Caso C (regresi√≥n): ASK_NAME texto sigue funcionando (handled ASK_NAME_TEXT ok)

NOTAS:
- El handler de ASK_PROBLEM_TEXT setea session.problem para que el handler existente lo procese, pero NO hace return expl√≠cito porque el handler existente debe ejecutarse y hacer return en todos sus caminos.
- El guardrail espec√≠fico para ASK_PROBLEM es una capa de seguridad adicional que se ejecuta ANTES del fallback gen√©rico, evitando que el usuario vea "Estoy tardando..." en casos normales de ASK_PROBLEM.
- Si el handler existente de ASK_PROBLEM no responde, el guardrail responder√° con un mensaje √∫til espec√≠fico para ASK_PROBLEM.
- BTN_RETRY ya estaba correctamente implementado (ver CHG-20251224-004).

------------------------------------------------------------

