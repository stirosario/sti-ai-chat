REGISTRO ÚNICO DE CAMBIOS - CHATBOT TECNOS
===========================================
Fecha inicio: 2025-12-24
Objetivo: Auditar y mejorar el ChatBot Tecnos con foco en coherencia del flujo conversacional, memoria de sesión y observabilidad.

UBICACIÓN: C:\sti-ai-chat\CHANGELOG_TECNOS.txt

===========================================
ENTRADAS DE CAMBIOS
===========================================

------------------------------------------------------------
ID CAMBIO: CHG-20251224-001
ETAPA: 1.A
ARCHIVO(S): C:\sti-ai-chat\server.js
MOTIVO:
- El endpoint /api/chat no garantizaba un contrato estable de respuesta con todos los campos requeridos (conversation_id, session_id, correlation_id, message_id, parent_message_id, stage, actor, text, buttons[], latency_ms, error_code).
- Las respuestas podían faltar campos críticos para observabilidad y trazabilidad.
- No había logs estructurados JSON por turno para análisis posterior.
- El lastBotMessageId solo se actualizaba para respuestas con botones, no para todas las respuestas del bot.

ANTES (snippet):
<<<
// Helper para retornar y loggear automáticamente
const logAndReturn = async (response, stage, nextStage, trigger = 'N/A', action = 'response_sent', sessionParam = null) => {
  // ...
  return res.json(response); // Respuesta sin normalización
};

// A4: Solo actualizaba lastBotMessageId si había botones
if ((who === 'bot' || who === 'assistant') && finalButtons && Array.isArray(finalButtons) && finalButtons.length > 0) {
  session.lastBotMessageId = message_id;
  // ...
}
>>>

DESPUÉS (snippet):
<<<
// ETAPA 1.A: Helper para normalizar respuesta del endpoint /api/chat
function normalizeChatResponse(response, session, correlationId, latencyMs, clientMessageId = null, parentMessageId = null) {
  // Garantiza campos: conversation_id, session_id, correlation_id, message_id, parent_message_id, stage, actor, text, buttons[], latency_ms, error_code
  // ...
}

// Helper para retornar y loggear automáticamente
const logAndReturn = async (response, stage, nextStage, trigger = 'N/A', action = 'response_sent', sessionParam = null) => {
  // ...
  const normalizedResponse = normalizeChatResponse(/* ... */);
  // Log estructurado JSON por turno
  console.log(JSON.stringify({
    event: 'CHAT_TURN',
    correlation_id: correlationId,
    conversation_id: currentSession?.conversationId || null,
    // ... todos los campos con PII enmascarado
  }));
  return res.json(normalizedResponse);
};

// ETAPA 1.A: Actualizar lastBotMessageId para TODAS las respuestas del bot
if (who === 'bot' || who === 'assistant') {
  session.lastBotMessageId = message_id;
  // ...
}
>>>

IMPACTO ESPERADO:
- Todas las respuestas de /api/chat ahora incluyen el contrato completo de campos requeridos.
- Logs estructurados JSON por turno (una línea por evento) con PII enmascarado para análisis.
- lastBotMessageId se actualiza para TODAS las respuestas del bot (no solo con botones).
- Mejora la observabilidad y trazabilidad de las conversaciones.

PRUEBA RÁPIDA DE VERIFICACIÓN:
- Paso 1: Enviar un mensaje al endpoint /api/chat
- Paso 2: Verificar en la respuesta JSON que incluye: conversation_id, session_id, correlation_id, message_id, parent_message_id, stage, actor, text, buttons, latency_ms
- Paso 3: Verificar en los logs del servidor que se emite una línea JSON con event="CHAT_TURN"
- Resultado esperado: Respuesta normalizada con todos los campos y log estructurado visible

NOTAS:
- La función normalizeChatResponse está disponible para ser usada en todos los lugares donde se retorna una respuesta.
- Pendiente: Actualizar otros lugares donde se retorna res.json() directamente (se hará en siguientes cambios incrementales).

------------------------------------------------------------
ID CAMBIO: CHG-20251224-002
ETAPA: 1.D (P0-FIX)
ARCHIVO(S): C:\sti-ai-chat\server.js
MOTIVO:
- Fix crítico: el chat se quedaba en "TECNOS... (pensando)" porque las llamadas a OpenAI no tenían timeout REAL.
- El AbortController se creaba pero el signal no se pasaba correctamente al SDK (se pasaba dentro de params en lugar de como segundo parámetro de opciones).
- El timeout de 30s empataba con el timeout del frontend (30s), causando que el usuario viera "pensando" indefinidamente.
- No había un hard timeout a nivel de request del endpoint /api/chat.

ANTES (snippet):
<<<
// AbortController decorativo que no funciona
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 30000);
const r = await openai.chat.completions.create({
  model: OPENAI_MODEL,
  messages: [...],
  temperature: 0,
  signal: controller.signal // ❌ INCORRECTO: signal dentro de params
});
clearTimeout(timeoutId);
>>>

DESPUÉS (snippet):
<<<
// Wrapper único con timeout REAL
async function callOpenAIWithTimeout(params, options = {}) {
  const { timeoutMs = 15000, correlationId, stage, label } = options;
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    // ✅ CORRECTO: signal como segundo parámetro (opciones de request)
    const response = await openai.chat.completions.create(params, {
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    // Logs estructurados: AI_CALL_START, AI_CALL_END, AI_CALL_TIMEOUT
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    // Manejo de timeout y errores...
  }
}

// Uso en funciones:
const r = await callOpenAIWithTimeout({
  model: OPENAI_MODEL,
  messages: [...],
  temperature: 0
}, {
  timeoutMs: 12000, // < 30s para no empatar frontend
  correlationId: session?.correlationId,
  stage: session?.stage,
  label: 'aiQuickTests'
});

// Hard timeout en /api/chat (25s)
const HARD_TIMEOUT_MS = 25000;
const hardTimeout = setTimeout(() => {
  if (!hasResponded && !res.headersSent) {
    // Responder con mensaje seguro + botones
  }
}, HARD_TIMEOUT_MS);

// Garantía "siempre se responde" al final del try
if (!hasResponded && !res.headersSent) {
  // Responder con mensaje seguro
}
>>>

IMPACTO ESPERADO:
- Todas las llamadas a OpenAI ahora tienen timeout REAL que funciona correctamente.
- Timeouts configurados < 30s (12s para quick tests, 15-18s para análisis) para evitar empatar con frontend.
- Hard timeout de 25s en /api/chat garantiza que el request siempre responda antes del timeout del frontend.
- Logs estructurados (AI_CALL_START, AI_CALL_END, AI_CALL_TIMEOUT) para observabilidad.
- Garantía de respuesta: si ninguna rama retorna, se envía respuesta segura antes de salir del handler.

PRUEBA RÁPIDA DE VERIFICACIÓN:
- Paso 1: Enviar mensaje que active análisis de OpenAI (ej: problema complejo)
- Paso 2: Verificar que responde antes de 25s (idealmente < 5s si no usa IA)
- Paso 3: Simular OpenAI lento (deshabilitar API key o timeout artificial) - debe responder con fallback
- Paso 4: Verificar en logs que aparecen eventos AI_CALL_START/END/TIMEOUT con correlation_id
- Resultado esperado: Chat nunca se queda en "pensando", siempre responde con mensaje útil

NOTAS:
- Todos los timeouts configurados: 12s (quick tests), 15s (análisis/explicaciones), 18s (análisis con imágenes).
- Hard timeout de 25s es < 30s del frontend, dejando margen para respuesta.
- Wrapper único centraliza lógica de timeout y logging.

------------------------------------------------------------
ID CAMBIO: CHG-20251224-003
ETAPA: 1.D (P0-FIX)
ARCHIVO(S): C:\sti-ai-chat\server.js
MOTIVO:
- Bug crítico: cuando el usuario ESCRIBE texto en stage=ASK_NAME (ej: "Pablo"), el backend no enruta al handler ASK_NAME y cae en fallback NO_RESPONSE_PATH.
- El handler de ASK_NAME estaba ubicado después de otras lógicas, causando que el request llegara al fallback antes de ejecutar el handler.
- El handler antiguo usaba res.json() directamente sin normalizeChatResponse ni logs estructurados.
- No había logs de diagnóstico para rastrear el flujo de enrutado por stage.

ANTES (snippet):
<<<
// Handler ASK_NAME ubicado después de otras lógicas (línea ~8545)
// ... código que puede hacer return antes ...
if (session.stage === STATES.ASK_NAME) {
  // ... handler antiguo ...
  return res.json(response); // Sin normalización, sin logs estructurados
}

// Más abajo: fallback NO_RESPONSE_PATH
if (!hasResponded && !res.headersSent) {
  // Retorna fallback "Estoy tardando..."
}
>>>

DESPUÉS (snippet):
<<<
// ETAPA 1.D (P0-FIX): STAGE ROUTER EXPLÍCITO - ANTES de cualquier otra lógica (línea ~7696)
console.log(`[ROUTER] enter stage=${session.stage} action=${action} msgLen=${effectiveText?.length || 0} hasButton=${!!buttonToken}`);

// ASK_NAME: Procesar texto o botón para recolección de nombre
if (session.stage === STATES.ASK_NAME) {
  console.log(`[ROUTER] handling ASK_NAME - action=${action} hasButton=${!!buttonToken} textLen=${effectiveText?.length || 0}`);
  
  // Procesar TEXTO para nombre (solo si no es botón)
  if (!buttonToken && (action === 'message' || action === 'text') && effectiveText && effectiveText.trim().length > 0) {
    const nameText = effectiveText.trim();
    // ... validación y procesamiento ...
    
    // Nombre válido - transición a ASK_PROBLEM
    session.userName = candidate;
    await setStage(session, STATES.ASK_PROBLEM, 'ASK_NAME_completed', { session_id: sid });
    
    const response = normalizeChatResponse({
      ok: true,
      reply,
      stage: session.stage,
      options: [],
      buttons: []
    }, session, correlationId, latencyMs, clientMessageId, null);
    
    const logTurn = {
      event: 'CHAT_TURN',
      timestamp_iso: new Date().toISOString(),
      correlation_id: correlationId,
      // ... todos los campos ...
    };
    console.log(JSON.stringify(logTurn));
    console.log(`[ROUTER] handled ASK_NAME_TEXT ok userName=${candidate} nextStage=ASK_PROBLEM`);
    
    clearHardTimeout();
    return res.json(response); // ✅ SIEMPRE retorna aquí
  }
}

// Firma de build al iniciar servidor
const BUILD_TAG = process.env.BUILD_TAG || 'local-dev';
const BUILD_COMMIT = process.env.BUILD_COMMIT || process.env.HEROKU_SLUG_COMMIT || 'unknown';
console.log(`[BUILD_INFO] STI Chat (v7) - BUILD_TAG: ${BUILD_TAG} - COMMIT: ${BUILD_COMMIT.substring(0, 8)}`);
>>>

IMPACTO ESPERADO:
- El handler de ASK_NAME ahora se ejecuta ANTES de cualquier otra lógica, garantizando que los requests con stage=ASK_NAME se procesen correctamente.
- Los logs [ROUTER] permiten diagnosticar el flujo de enrutado por stage.
- Las respuestas usan normalizeChatResponse para contrato consistente y logs estructurados.
- La firma de build permite verificar que se está ejecutando el archivo correcto en producción.
- El handler antiguo fue deshabilitado (comentado) para evitar duplicación.

PRUEBA RÁPIDA DE VERIFICACIÓN:
- Paso 1: Consent YES -> Language ES -> En ASK_NAME escribir "Pablo"
- Resultado esperado: respuesta 200, stage=ASK_PROBLEM, reply pregunta problema, SIN fallback "Estoy tardando…"
- Paso 2: ASK_NAME con botón "Prefiero no decirlo"
- Resultado esperado: stage=ASK_PROBLEM ok
- Paso 3: Verificar logs del servidor para ver [ROUTER] enter stage=ASK_NAME y [ROUTER] handled ASK_NAME_TEXT ok
- Paso 4: Verificar BUILD_INFO en logs al iniciar servidor para confirmar archivo correcto

NOTAS:
- El handler antiguo de ASK_NAME (línea ~8771) fue comentado para evitar ejecución duplicada.
- La firma de build se imprime al iniciar el servidor para verificar que se ejecuta el archivo correcto en Render/producción.
- El nuevo handler está ubicado justo después de persistir el mensaje del usuario y antes del router de botones.
- Los timeouts de OpenAI ya están correctamente implementados (ver CHG-20251224-002).

------------------------------------------------------------

