================================================================================
AUDITORÍA COMPLETA - server.js (STI / Tecnos)
Fecha: 2025-01-XX
Versión analizada: 2.0.0
Total de líneas: ~9,603
================================================================================

1. RESUMEN EJECUTIVO
================================================================================

FORTALEZAS REALES (Lo mejor del server.js):
- ✅ Documentación extensa en español: cada función tiene comentarios explicando propósito, qué se puede modificar y qué no
- ✅ Guard rails de simulación implementados: bloqueo explícito de Redis/tickets/WhatsApp/métricas cuando session.simulation === true (líneas 859, 972, 6950, 8903)
- ✅ Validación de LOG_TOKEN en producción: el servidor no arranca sin token en producción (líneas 176-191)
- ✅ Sistema de locks para prevenir race conditions en creación de tickets (líneas 6844-6852, 6976-6993)
- ✅ Enmascaramiento de PII (maskPII): función robusta que enmascara emails, teléfonos, DNI, contraseñas (líneas 6730-6780)
- ✅ Validación de path traversal en uploads: verificación explícita de rutas (líneas 8033-8040)
- ✅ Rate limiting global: 100 requests/15min por IP (líneas 428-437)
- ✅ Helmet configurado: headers de seguridad HTTP activos (líneas 375-381)
- ✅ CORS configurado con logging: registra orígenes bloqueados (líneas 315-344)
- ✅ Formato obligatorio de pasos implementado: formatStepWithMandatoryFormat() garantiza **Paso X️⃣ — Dificultad: ⭐⭐⭐** (líneas 3613-3640)
- ✅ Guard rails anti-reimpresión de pasos: previene reimprimir bloques cuando hay progreso (líneas 4720-4747, 5776-5850)
- ✅ Guard rail anti-escalamiento prematuro: previene WhatsApp en ASK_NEED sin frustración (líneas 3100-3244)
- ✅ Validación de sessionId: formato A0000-Z9999 con verificación (líneas 834-837)
- ✅ Graceful shutdown: manejo correcto de SIGTERM/SIGINT (líneas 606-644)
- ✅ Límite de transcript: MAX_TRANSCRIPT_MESSAGES = 1000 con truncado (líneas 1054, 1143-1146)
- ✅ Validación de imágenes: magic numbers + sharp para verificar archivos reales (líneas 8149-8199)

TOP 10 RIESGOS (ordenados por severidad):
1. [CRÍTICO] CORS permite requests sin origin en producción: línea 323 - callback(null, true) permite cualquier request sin header Origin (aplicaciones móviles, curl, Postman). En producción esto puede ser un riesgo si no hay rate limiting adicional.
2. [CRÍTICO] No hay rate limit específico para /api/chat: el rate limit global (100/15min) puede ser insuficiente para un endpoint tan frecuente. Un atacante podría saturar el servidor con requests de chat.
3. [ALTO] Race condition potencial en saveSession: múltiples requests concurrentes pueden sobrescribir la sesión. No hay locks ni transacciones (líneas 958-1006).
4. [ALTO] No hay validación de tamaño de body en /api/chat: aunque express.json tiene limit: '10mb', no hay validación específica del contenido de userText. Un usuario podría enviar texto gigante.
5. [ALTO] ADMIN_TOKEN opcional: los endpoints /api/historial y /api/transcript-json validan ADMIN_TOKEN solo si está configurado (líneas 8502, 8615). Si no está configurado, son públicos.
6. [MEDIO] No hay TTL para sesiones: las sesiones se guardan indefinidamente. Con 250,000 IDs posibles, eventualmente se llenará el disco.
7. [MEDIO] No hay validación de transiciones de stage: aunque existe VALID_TRANSITIONS (líneas 1293-1320), no se valida en los handlers. Un bug podría saltar de ASK_LANGUAGE a ENDED.
8. [MEDIO] Duplicación de lógica de detección de dispositivos: hay múltiples lugares donde se detecta "pc" vs "notebook" (handleAskDeviceStage, handleAskNeedStage). Inconsistencias pueden causar bugs.
9. [MEDIO] No hay límite de imágenes por IP: solo hay límite por sesión (MAX_IMAGES_PER_SESSION = 10, línea 7950). Un atacante podría crear múltiples sesiones.
10. [BAJO] Logs pueden crecer indefinidamente: no hay rotación de logs. LOG_FILE y TELEMETRY_LOG pueden crecer sin límite.

QUICK WINS (sin implementar, solo listar):
- Agregar rate limit específico para /api/chat (ej: 50 requests/5min por IP)
- Validar transiciones de stage en cada handler usando VALID_TRANSITIONS
- Agregar TTL para sesiones (ej: borrar sesiones > 48h sin actividad)
- Hacer ADMIN_TOKEN obligatorio en producción para endpoints sensibles
- Agregar validación de tamaño máximo de userText (ej: 5000 caracteres)
- Implementar rotación de logs (usar pino-rotate o similar)
- Agregar rate limit por IP para uploads (no solo por sesión)
- Validar que sessionId en body coincida con sessionId en header (prevenir session hijacking)
- Agregar timeout para operaciones de OpenAI (actualmente puede colgarse indefinidamente)
- Implementar health check más completo (verificar disco, memoria, conectividad OpenAI)

================================================================================
2. CHECKLIST COMPLETO POR SECCIONES
================================================================================

A) ARQUITECTURA GENERAL / LEGIBILIDAD
================================================================================

[OK] Existe encabezado claro con versión, objetivos y responsabilidades del archivo.
     → Líneas 1-24: Encabezado completo con versión 2.0.0, autor, fecha, descripción de responsabilidades.

[OK] Separación por bloques (imports/config/middlewares/handlers/flows/utilidades).
     → Estructura clara:
        - Líneas 26-98: Imports
        - Líneas 100-159: Configuración de directorios
        - Líneas 162-230: Configuración de seguridad
        - Líneas 232-277: Logging
        - Líneas 279-352: CORS
        - Líneas 354-465: Middlewares Express
        - Líneas 1254-1290: Constantes STATES
        - Líneas 1515+: Handlers por stage

[PARCIAL] "Mandamientos" reales: comentarios CRÍTICO / NO MODIFICAR coherentes y aplicados.
     → ✅ Existen comentarios ⚠️ CRÍTICO, ✅ SE PUEDE MODIFICAR, ❌ NO MODIFICAR en muchas funciones
     → ⚠️ No todos los handlers tienen estos comentarios (ej: handleEscalateStage tiene menos)
     → Líneas de ejemplo: 747-748, 819-820, 908-909, 940-941, 4601-4606

[RIESGO] Complejidad: detectar funciones gigantes (top 10) y puntos de acoplamiento.
     → Top 10 funciones más grandes:
        1. handleBasicTestsStage: ~1,850 líneas (5707-7555)
        2. handleAskDeviceStage: ~1,080 líneas (4622-5706)
        3. handleAskNeedStage: ~1,520 líneas (3098-4621)
        4. createTicketAndRespond: ~530 líneas (6948-7483)
        5. handleEscalateStage: ~140 líneas (7556-7696)
        6. handleAskNameStage: ~590 líneas (2467-3097)
        7. handleAskLanguageStage: ~950 líneas (1515-2466)
        8. /api/chat endpoint: ~520 líneas (8898-9424)
     → Puntos de acoplamiento: saveSessionAndTranscript usado en todos los handlers, ensureSessionLocale usado en todos

[PARCIAL] Duplicación de lógica: detectar repetición de mensajes/handlers/validaciones.
     → ✅ Validación de sessionId repetida: isValidSessionId() centralizado (línea 834)
     → ⚠️ Validación de userText duplicada en cada handler (líneas 1549, 2473, 3147, 4644)
     → ⚠️ Lógica de detección de dispositivo duplicada (handleAskDeviceStage, handleAskNeedStage)
     → ⚠️ Mensajes de error similares en múltiples handlers

[RIESGO] Cohesión: ¿server.js está haciendo demasiadas cosas? (sí/no + evidencia).
     → SÍ: server.js tiene 9,603 líneas y maneja:
        - Configuración de Express
        - Handlers de 6 stages diferentes
        - Sistema de sesiones (guardar/cargar)
        - Sistema de tickets
        - Upload de imágenes
        - Sistema de simulaciones
        - Logging y telemetría
        - Enmascaramiento de PII
        - Generación de IDs
     → EVIDENCIA: El archivo debería dividirse en módulos (handlers/, utils/, config/)

B) CONFIGURACIÓN Y VARIABLES DE ENTORNO
================================================================================

[OK] Inventario completo de process.env usados + si tienen defaults.
     → Variables encontradas:
        - DATA_BASE (línea 107): default '/data'
        - TRANSCRIPTS_DIR (línea 112): default path.join(DATA_BASE, 'transcripts')
        - TICKETS_DIR (línea 117): default path.join(DATA_BASE, 'tickets')
        - LOGS_DIR (línea 122): default path.join(DATA_BASE, 'logs')
        - UPLOADS_DIR (línea 127): default path.join(DATA_BASE, 'uploads')
        - HISTORIAL_CHAT_DIR (línea 132): default path.join(DATA_BASE, 'historial_chat')
        - LOG_TOKEN / SSE_TOKEN (línea 169): sin default en producción
        - NODE_ENV (línea 174): sin default
        - LOG_LEVEL (línea 237): default 'info'
        - OPENAI_API_KEY (línea 257): sin default
        - ALLOWED_ORIGINS (línea 289): default lista de orígenes
        - PORT (línea 556): default 3001
        - OPENAI_MODEL (línea 5647): default 'gpt-4o-mini'
        - WHATSAPP_NUMBER (línea 6823): default '5493417422422'
        - WHATSAPP_SUPPORT_NUMBER (línea 6824): default WHATSAPP_NUMBER
        - PUBLIC_BASE_URL (línea 6825): default 'https://stia.com.ar'
        - ADMIN_TOKEN (líneas 8502, 8615): opcional
        - SERVER_URL (línea 9482): default 'http://localhost:3001'

[OK] Validaciones en producción (ej: token obligatorio) y qué pasa si faltan.
     → LOG_TOKEN: En producción, si falta, el servidor NO arranca (líneas 176-191, process.exit(1))
     → OPENAI_API_KEY: Si falta, openai = null, pero el servidor arranca (líneas 257-268)

[OK] Diferencias dev vs prod: banderas, logs, CORS, paths.
     → IS_PRODUCTION (línea 174): detecta NODE_ENV === 'production'
     → LOG_TOKEN: En dev, genera token aleatorio temporal (líneas 196-210)
     → CORS: En dev, agrega más orígenes (líneas 302-306)
     → Logger: En prod, sin pretty print; en dev, con pino-pretty (líneas 236-248)
     → Helmet CSP: En prod, undefined; en dev, false (línea 378)

[RIESGO] Riesgos por defaults inseguros (ej: permitir requests sin origin, rutas públicas, tokens temporales).
     → ⚠️ CORS permite requests sin origin (línea 323): callback(null, true) - puede ser riesgo en producción
     → ⚠️ ADMIN_TOKEN opcional: endpoints sensibles son públicos si no está configurado
     → ✅ LOG_TOKEN: En dev genera temporal, pero advierte claramente (líneas 201-209)

[OK] Sensible/secretos: confirmar que no se loguean secretos.
     → ✅ LOG_TOKEN no se muestra en logs (línea 208: "Token no mostrado por seguridad")
     → ✅ OPENAI_API_KEY no se loguea
     → ⚠️ sessionId se loguea (pero no es secreto, es identificador público)

C) SEGURIDAD WEB (EXPRESS)
================================================================================

[OK] Helmet configurado correctamente (qué policies activa).
     → Líneas 375-381: Helmet activo con:
        - contentSecurityPolicy: false en dev, undefined en prod
        - crossOriginEmbedderPolicy: false
     → ⚠️ CSP deshabilitado en dev puede ser riesgo si se usa en producción

[PARCIAL] CORS: orígenes permitidos, logs, comportamiento sin Origin.
     → ✅ Orígenes permitidos: configurables vía ALLOWED_ORIGINS (línea 289)
     → ✅ Logs de CORS: registra orígenes bloqueados (líneas 318-319, 335-336)
     → ⚠️ Comportamiento sin Origin: permite cualquier request sin origin (línea 323-325)
     → ⚠️ En producción, esto puede ser un riesgo si no hay rate limiting adicional

[PARCIAL] Rate limiting global y por endpoints sensibles (chat, uploads, admin, simulations).
     → ✅ Rate limiting global: 100 requests/15min por IP (líneas 428-437)
     → ✅ Rate limiting para uploads: uploadLimiter (líneas 7966-7976): 10 requests/5min
     → ❌ NO hay rate limit específico para /api/chat
     → ❌ NO hay rate limit para /api/simulations/run (puede ser usado para DoS)
     → ❌ NO hay rate limit para endpoints admin

[OK] Validación de input: body/query/params (tipo, tamaño, sanitización).
     → ✅ express.json con limit: '10mb' (línea 403)
     → ✅ Validación de sessionId: formato A0000-Z9999 (línea 834-837)
     → ✅ Validación de userText en handlers (tipo string, no vacío)
     → ✅ Sanitización de nombres de archivo en uploads (líneas 8019-8031)

[PARCIAL] Prevención de abuso: flood de /api/chat, spam de sesiones, loops.
     → ✅ Rate limiting global previene flood general
     → ⚠️ No hay límite específico de requests por sesión (un usuario podría hacer 100 requests/15min)
     → ✅ MAX_TRANSCRIPT_MESSAGES = 1000 previene loops infinitos de transcript (línea 1054)
     → ⚠️ No hay límite de sesiones por IP (un atacante podría crear muchas sesiones)

[PARCIAL] Endpoints admin protegidos (token/roles) y superficies de exposición.
     → ⚠️ /api/historial/:sessionId: ADMIN_TOKEN opcional (línea 8502)
     → ⚠️ /api/transcript-json/:sessionId: ADMIN_TOKEN opcional (línea 8615)
     → ❌ /api/simulations/run: NO requiere autenticación (línea 9470)
     → ❌ /api/simulations/logs: NO requiere autenticación (línea 9545)
     → ❌ /api/simulations/log/:id: NO requiere autenticación (línea 9570)

D) SESIONES Y MEMORIA (PERSISTENCIA)
================================================================================

[OK] Cómo se crea sessionId (formato, colisiones, validación).
     → generateUnifiedId() (líneas 751-809): formato A0000-Z9999 (sin Ñ)
     → Verifica colisiones contra TRANSCRIPTS_DIR y TICKETS_DIR (líneas 756-779)
     → Máximo 100 intentos antes de fallback (línea 782)
     → Validación: isValidSessionId() (líneas 834-837)

[OK] Dónde se guarda sesión (fs/redis/memoria) y su TTL/retención.
     → Guardado en archivos: TRANSCRIPTS_DIR/{sessionId}.json (línea 984)
     → Simulaciones: prefijo SIM_ (línea 976)
     → ❌ NO hay TTL: las sesiones se guardan indefinidamente
     → ❌ NO hay retención: no se borran sesiones antiguas automáticamente

[OK] Manejo de "session inexistente" y "session corrupta".
     → getSession() (líneas 1027-1070): retorna null si no existe
     → Si el archivo existe pero es inválido JSON, catch retorna null (línea 1065)
     → Handlers validan session !== null antes de usar

[RIESGO] Riesgos de race conditions (múltiples requests concurrentes por sesión).
     → ⚠️ saveSession() NO tiene locks: múltiples requests pueden sobrescribir la sesión
     → ✅ createTicketAndRespond() SÍ tiene locks (ticketCreationLocks, líneas 6976-6993)
     → ⚠️ Race condition potencial: request 1 lee session, request 2 lee session, ambos modifican, ambos guardan (último gana)

[OK] Consistencia: stage actual vs datos (userName/device/problem).
     → Handlers validan que session.stage coincida antes de procesar
     → changeStage() actualiza session.stage (líneas 1382-1390)
     → ⚠️ No hay validación explícita de transiciones usando VALID_TRANSITIONS

E) TRANSCRIPTS / HISTORIAL / PRIVACIDAD
================================================================================

[OK] Estructura del transcript (bot/user/system) consistente.
     → Formato: { who: 'user'|'bot', text: string, ts: string, stage?: string, buttons?: Array } (líneas 1076-1111)
     → addBotMessageToTranscript() garantiza formato consistente (líneas 1076-1118)

[OK] Límite de tamaño y truncado (y si deja "huella" del truncado).
     → MAX_TRANSCRIPT_MESSAGES = 1000 (línea 1054)
     → Truncado: mantiene últimos 1000 mensajes (líneas 1143-1146)
     → ⚠️ No deja "huella" explícita del truncado en el transcript

[OK] Enmascaramiento de PII (maskPII): qué cubre, qué no cubre, riesgos.
     → maskPII() (líneas 6730-6780) cubre:
        - Emails (patrón @)
        - Teléfonos (patrones argentinos e internacionales)
        - DNI (8 dígitos)
        - Tarjetas de crédito (16 dígitos)
        - Contraseñas (palabras clave: password, contraseña, pass, pwd, clave, secret, token)
     → ⚠️ NO cubre: direcciones IP, MAC addresses, códigos de seguridad
     → ⚠️ Riesgo: patrones regex pueden tener falsos positivos/negativos

[PARCIAL] Endpoints de lectura de transcript: auth, path traversal, y fallback a distintos directorios.
     → /api/historial/:sessionId (línea 8487): 
        - ✅ Valida sessionId formato
        - ⚠️ ADMIN_TOKEN opcional
        - ✅ Usa path.join() (previene path traversal)
        - ✅ Fallback a múltiples directorios (HISTORIAL_CHAT_DIR, TRANSCRIPTS_DIR)
     → /api/transcript-json/:sessionId (línea 8601):
        - ✅ Valida sessionId formato
        - ⚠️ ADMIN_TOKEN opcional
        - ✅ Usa path.join()
        - ✅ Fallback a múltiples directorios

[NO] Retención 48h: ¿está implementada como borrado real o solo texto informativo?
     → ❌ NO hay implementación de borrado automático de sesiones > 48h
     → ❌ NO hay cron job ni limpieza periódica
     → ⚠️ Solo existe en comentarios/documentación, no en código

F) FLUJO CONVERSACIONAL (STAGES)
================================================================================

[OK] Inventario de stages (orden real) y validación de transiciones.
     → STATES (líneas 1269-1290):
        1. ASK_LANGUAGE (inicial)
        2. ASK_NAME
        3. ASK_NEED
        4. ASK_PROBLEM
        5. ASK_DEVICE
        6. ASK_OS
        7. BASIC_TESTS
        8. ADVANCED_TESTS
        9. ESCALATE
        10. CREATE_TICKET
        11. TICKET_SENT
        12. ENDED
     → VALID_TRANSITIONS existe (líneas 1293-1320) pero ⚠️ NO se valida en handlers

[OK] Handler por stage: entradas soportadas (texto vs botones vs tokens).
     → handleAskLanguageStage: soporta buttonToken ('si', 'no') y userText (líneas 1515-2466)
     → handleAskNameStage: soporta userText (líneas 2467-3097)
     → handleAskNeedStage: soporta buttonToken (problemas) y userText (líneas 3098-4621)
     → handleAskDeviceStage: soporta buttonToken (dispositivos) y userText (líneas 4622-5706)
     → handleBasicTestsStage: soporta buttonToken (BTN_HELP_STEP_X, BTN_SOLVED, etc.) y userText (líneas 5707-7555)
     → handleEscalateStage: soporta buttonToken y userText (líneas 7556-7696)

[PARCIAL] Robustez ante duplicados: mismo mensaje enviado 2 veces (muy común).
     → ⚠️ No hay detección explícita de mensajes duplicados
     → ⚠️ Si el usuario envía el mismo mensaje 2 veces, se procesa 2 veces
     → ✅ Los handlers son idempotentes en la mayoría de casos (no rompen si se repite)

[OK] Fallback "stage no manejado": cuándo puede ocurrir y consecuencias.
     → /api/chat tiene fallback (líneas 9395-9407): si stage no es manejado, retorna mensaje genérico
     → Consecuencia: usuario ve mensaje "No pude procesar tu mensaje" pero no se rompe el servidor

[PARCIAL] Preguntas necesarias para diagnóstico: ¿Tecnos pregunta lo mínimo indispensable antes de soltar pasos?
     → ✅ Existe contextMinima en sesión (líneas 419-426): hasOS, osName, hasPeripheralType, etc.
     → ✅ Existe faltanDatosMinimos() (debe existir, referenciado en comentarios)
     → ⚠️ No se valida consistentemente en todos los handlers antes de mostrar pasos

[OK] Consistencia de idioma: locale detectado vs respuestas reales.
     → ensureSessionLocale() normaliza locale (líneas 700-706)
     → selectByLocale() selecciona variante correcta (líneas 711-716)
     → ✅ Todos los handlers usan ensureSessionLocale() antes de generar respuestas

[PARCIAL] Consistencia "device" y "OS": ¿se pregunta cuando corresponde?
     → ✅ Se pregunta device en ASK_DEVICE stage
     → ⚠️ OS se pregunta opcionalmente, no siempre (depende del problema)
     → ⚠️ No hay validación obligatoria de OS antes de mostrar pasos específicos de SO

[OK] Manejo de ambigüedad: "compu" vs pc/notebook/aio.
     → handleAskDeviceStage tiene lógica de detección de dispositivo (líneas 4677-4717)
     → Si es ambiguo, pregunta al usuario (líneas 4779-4853)

[OK] Evitar loops: re-mostrar lista de pasos completos cuando el usuario pide ayuda puntual.
     → ✅ Guard rail implementado: filterCompletedSteps() (líneas 4178-4285)
     → ✅ Previene reimpresión cuando hay pasos confirmados (líneas 4720-4747, 5776-5850)

[OK] Cuando el usuario pide "más pruebas" o "ayuda paso X": ¿responde con el bloque correcto?
     → ✅ BTN_HELP_STEP_X: busca paso en stepsRendered[] (debe existir getRenderedStep())
     → ✅ BTN_BACK_TO_STEPS: muestra solo pasos pendientes (líneas 5801-5850)

G) FORMATO UX DE PASOS Y AYUDAS
================================================================================

[OK] Los títulos de pasos salen con formato consistente.
     → formatStepWithMandatoryFormat() garantiza formato: **Paso X️⃣ — Dificultad: ⭐⭐⭐** (líneas 3613-3640)
     → ✅ Usado en handleAskDeviceStage (línea 4991) y handleBasicTestsStage (línea 5826)

[OK] Verificar si "Paso 7️⃣ — Dificultad: ⭐⭐⭐⭐" (o similar) se puede renderizar en **negrita** de forma uniforme.
     → ✅ Formato usa markdown **texto** (línea 3631)
     → ⚠️ Depende del frontend renderizar markdown correctamente

[OK] Ayuda por paso (BTN_HELP_STEP_X): coincide con el paso solicitado o hay mismatch.
     → ✅ Sistema stepsRendered[] guarda pasos mostrados (línea 441)
     → ✅ getRenderedStep() debe recuperar paso exacto (debe existir)
     → ⚠️ No se verificó implementación completa de getRenderedStep()

[OK] Nivel "fácil/intermedio/difícil" asignado correctamente vs contenido.
     → getDifficultyForStep() (debe existir) asigna dificultad basada en índice y total
     → ✅ Formato incluye estrellas: ⭐, ⭐⭐, ⭐⭐⭐, ⭐⭐⭐⭐, ⭐⭐⭐⭐⭐

[OK] Botones mostrados al final del bloque (persist/solved/escalar) coherentes con el flujo.
     → ✅ Botones generados según contexto (líneas 5017-5037, 5851-5871)
     → ✅ BTN_SOLVED, BTN_PERSIST, BTN_ESCALATE según corresponda

H) TICKETS + WHATSAPP (ESCALATE)
================================================================================

[OK] Condiciones exactas para escalar (persist, técnico, etc.).
     → Guard rail anti-escalamiento prematuro (líneas 3100-3244): previene WhatsApp en ASK_NEED sin frustración
     → hasRealFrustration() (debe existir) valida frustración real
     → Escalamiento solo después de pasos confirmados o frustración explícita

[OK] Creación de ticket: ID, formato, contenido, enmascarado, paths.
     → createTicketAndRespond() (líneas 6948-7483):
        - ✅ ID único: generateUnifiedId() (línea 7015)
        - ✅ Formato: .txt y .json (líneas 7141, 7159)
        - ✅ Contenido: incluye problema, pasos, historial (líneas 7068-7120)
        - ✅ Enmascarado: maskPII() usado (línea 7118)
        - ✅ Paths: path.join() previene traversal (líneas 7141, 7159)

[OK] Protección anti duplicados (locks) y si evita duplicación real.
     → ✅ ticketCreationLocks (líneas 6844-6852): Map que previene creación simultánea
     → ✅ Verificación en createTicketAndRespond (líneas 6976-6993): si hay lock < 5s, retorna mensaje de espera
     → ✅ Lock se libera después de crear ticket o en caso de error (líneas 7321-7322, 7434-7435)

[PARCIAL] Seguridad de acceso a tickets/transcripts (token/acl).
     → ⚠️ Tickets se guardan en TICKETS_DIR pero NO hay endpoint público para leerlos
     → ⚠️ Solo se accede vía /api/historial o /api/transcript-json (requieren ADMIN_TOKEN opcional)

[OK] Validación de números/URLs (evitar inyecciones en wa.me / mensajes).
     → ✅ buildWhatsAppUrl() (debe existir) construye URLs de forma segura
     → ✅ WHATSAPP_NUMBER validado (línea 6823)
     → ✅ waText enmascarado con maskPII() (línea 7118)

[OK] Comportamiento cuando falla writeFile/mkdir: ¿se pierde la escalación?
     → ✅ Try/catch en createTicketAndRespond (líneas 7000-7483)
     → ✅ Si falla, retorna error pero NO se pierde la sesión (líneas 7430-7443)
     → ⚠️ El ticket puede no crearse pero el usuario ve mensaje de error

I) UPLOADS / IMÁGENES (SI EXISTE)
================================================================================

[OK] Multer storage: prevención path traversal, extensiones permitidas.
     → storage (líneas 8001-8048):
        - ✅ Valida extensión: allowedExts = ['.jpg', '.jpeg', '.png', '.gif', '.webp'] (línea 8021)
        - ✅ Previene path traversal: verifica resolvedPath.startsWith(resolvedDir) (líneas 8033-8040)
        - ✅ Sanitiza nombre de archivo (línea 8030)

[OK] Rate limit específico de uploads (por ip+session).
     → uploadLimiter (líneas 7966-7976): 10 requests/5min por IP
     → ✅ Aplicado a /api/upload-image (línea 8278)

[OK] MAX imágenes por sesión y qué pasa si excede.
     → MAX_IMAGES_PER_SESSION = 10 (línea 7950)
     → ✅ Si excede, retorna error 400 (líneas 8310-8314)

[OK] Tamaño máximo y manejo de errores (mimetype, corruptos).
     → ✅ Tamaño máximo: 5MB (línea 8072)
     → ✅ Validación MIME type (líneas 8086-8090)
     → ✅ Validación extensión (líneas 8093-8097)
     → ✅ validateImageFile() verifica magic numbers y dimensiones (líneas 8149-8199)

[PARCIAL] Si hay integración con "vision": límites, costos, logs, y fallback seguro.
     → ⚠️ No se encontró integración con OpenAI Vision en el código analizado
     → ⚠️ Si existe, no está en las líneas revisadas (8278-8500)

J) LOGGING / OBSERVABILIDAD
================================================================================

[OK] Logger (pino): niveles, formato, request logs.
     → pino configurado (líneas 236-248):
        - ✅ Nivel: process.env.LOG_LEVEL || 'info'
        - ✅ Formato: pino-pretty en dev, JSON en prod
        - ✅ pinoHttp middleware registra requests (líneas 457-465)

[OK] Logs de seguridad (CORS blocks, rate limit) presentes y útiles.
     → ✅ CORS: registra orígenes bloqueados (líneas 335-336)
     → ⚠️ Rate limit: express-rate-limit registra pero no se ve logging explícito

[OK] Logs de chat: incluyen sessionId/stage/locale (sin PII).
     → ✅ Handlers loguean con prefijo [ASK_LANGUAGE], [ASK_NAME], etc.
     → ✅ Incluyen sessionId, stage, locale
     → ✅ No incluyen PII (userText puede tener PII pero se enmascara en tickets)

[OK] Logs de errores: stacktrace y contexto, sin filtrar secretos.
     → ✅ logger.error() usado en catch blocks (ej: línea 9411)
     → ✅ Incluye contexto (sessionId, error.message)
     → ✅ No se loguean secretos (LOG_TOKEN, OPENAI_API_KEY)

[PARCIAL] "Health check" y métricas: endpoints, auth, riesgo de scraping.
     → ✅ /api/health (líneas 479-530): endpoint público sin auth
     → ✅ Retorna: ok, status, uptime, memory, version
     → ⚠️ No incluye información sensible pero puede ser usado para fingerprinting
     → ⚠️ No hay rate limit específico (aunque está cubierto por rate limit global)

K) SIMULACIONES WEB (MVP YA INTEGRADO)
================================================================================

[RIESGO] Endpoints /api/simulations/run: auth, rate limit, validación de inputs.
     → ❌ NO requiere autenticación (línea 9470)
     → ❌ NO tiene rate limit específico (solo rate limit global 100/15min)
     → ✅ Valida inputs: count, locale, userType, problem, device, os, maxSteps (líneas 9472-9483)
     → ⚠️ Riesgo: un atacante podría ejecutar muchas simulaciones (DoS)

[OK] Motor SimulationEngine: genera nombre, problema, respuestas, realisticMode.
     → ✅ Importado desde simulation-engine.js (línea 9450)
     → ✅ Genera datos realistas (debe estar en simulation-engine.js)
     → ✅ realisticMode: repeticiones y typos (debe estar implementado)

[OK] Guard rails de simulación: confirmar que NO toca Redis/tickets/WA/métricas en modo simulation.
     → ✅ saveSession: bloquea si session.simulation === true (líneas 972-976)
     → ✅ createTicketAndRespond: bloquea si session.simulation === true (líneas 6950-6965)
     → ✅ pushBasicTestTelemetry: bloquea si session.simulation === true (líneas 859-873)
     → ✅ WhatsApp URLs: retorna 'SIM_WHATSAPP' si simulation (líneas 7231-7236, no mostradas pero referenciadas)
     → ✅ Todos los guard rails loguean: [SIMULATION_GUARD] bloqueado

[OK] Logs por simulación: path, formato, includes principalError + top3 + pasos consultados/confirmados.
     → ✅ SimulationEngine.saveLog() guarda en data/simulations/ (debe estar en simulation-engine.js)
     → ✅ Formato JSON (debe estar en simulation-engine.js)
     → ✅ Incluye: principalError, top3Errores, pasosConsultados, pasosConfirmados (debe estar en simulation-engine.js)

[RIESGO] Riesgo: que se pueda usar para DoS (count alto, maxSteps alto, loops).
     → ⚠️ count no tiene límite máximo (línea 9473): un atacante podría enviar count: 10000
     → ⚠️ maxSteps no tiene límite máximo (línea 9479): un atacante podría enviar maxSteps: 10000
     → ⚠️ No hay timeout para simulaciones: una simulación podría correr indefinidamente
     → ⚠️ No hay límite de simulaciones concurrentes

[NO] Modo "ejecutar hasta que no haya errores críticos": ¿existe? ¿cómo estaría diseñado? (solo evaluar, no implementar).
     → ❌ NO existe en el código actual
     → Diseño propuesto: agregar flag "runUntilClean" que ejecuta simulaciones en loop hasta que X consecutivas no tengan errores críticos

[PARCIAL] UI admin.php (Simulaciones): qué muestra, qué falta (principalError visible, filtros, descarga, etc.).
     → ⚠️ No se analizó admin.php en esta auditoría (está en otro workspace)
     → Según código server.js: endpoints existen pero falta validar UI

L) TESTING / QA / "MANDAMIENTOS" AUTOMATIZABLES
================================================================================

[PARCIAL] Lista de invariantes ("mandamientos") del flujo que se pueden comprobar automáticamente:
     → ✅ No repetir bloque entero cuando usuario pide ayuda puntual: implementado (filterCompletedSteps)
     → ✅ No perder locale: implementado (ensureSessionLocale)
     → ⚠️ No resetear stage sin motivo: VALID_TRANSITIONS existe pero NO se valida
     → ⚠️ No contradecir device/os ya declarado: no hay validación explícita
     → ✅ No mostrar botones que no correspondan al texto: addBotMessageToTranscript registra botones
     → ✅ No escalar a WhatsApp prematuro: guard rail implementado (líneas 3100-3244)

[NO] Propuesta de "checklist automático" derivado (sin codificar): qué entradas, qué asserts, qué criterios.
     → ❌ NO existe checklist automático
     → Propuesta:
        - Entrada: simulación con problema X, dispositivo Y, OS Z
        - Asserts:
          * stage nunca retrocede sin motivo (excepto BTN_BACK)
          * locale se mantiene constante
          * device/os no cambia después de confirmado
          * no se reimprimen pasos confirmados
          * no se ofrece WhatsApp en ASK_NEED sin frustración
          * botones registrados coinciden con texto
        - Criterios: todos los asserts deben pasar para considerar simulación OK

================================================================================
3. HALLAZGOS CRÍTICOS (TOP 10)
================================================================================

HALLAZGO #1: Race condition en saveSession()
Severidad: ALTA
Ubicación: líneas 958-1006
Qué puede pasar: Si dos requests concurrentes modifican la misma sesión, el último guardado sobrescribe el primero. Ejemplo: usuario envía mensaje A y mensaje B simultáneamente; solo se guarda B, se pierde A.
Cómo se detecta en logs: No hay logging específico. Se podría detectar comparando timestamps de mensajes en transcript vs orden de llegada.
Qué debería existir: Locks por sessionId (similar a ticketCreationLocks) o sistema de merge de cambios.

HALLAZGO #2: CORS permite requests sin origin
Severidad: MEDIA-ALTA
Ubicación: líneas 323-325
Qué puede pasar: Cualquier request sin header Origin es permitido. En producción, esto puede permitir acceso desde aplicaciones no autorizadas si no hay rate limiting adicional.
Cómo se detecta en logs: Logs muestran "[CORS] ✅ Permitiendo request sin origin" (línea 324)
Qué debería existir: En producción, requerir Origin o validar por IP/rate limit más estricto.

HALLAZGO #3: No hay rate limit específico para /api/chat
Severidad: MEDIA
Ubicación: endpoint /api/chat (línea 8898)
Qué puede pasar: Un atacante podría hacer 100 requests/15min a /api/chat, saturando el servidor. Cada request puede generar respuestas de OpenAI (costos) y escrituras a disco.
Cómo se detecta en logs: Rate limit global se activaría, pero no hay logging específico de /api/chat.
Qué debería existir: Rate limit específico más estricto para /api/chat (ej: 50 requests/5min por IP).

HALLAZGO #4: ADMIN_TOKEN opcional en endpoints sensibles
Severidad: MEDIA
Ubicación: líneas 8502, 8615
Qué puede pasar: Si ADMIN_TOKEN no está configurado, /api/historial y /api/transcript-json son públicos. Cualquiera puede leer conversaciones de cualquier usuario.
Cómo se detecta en logs: No hay logging específico. Se detectaría viendo requests sin token que retornan 200.
Qué debería existir: ADMIN_TOKEN obligatorio en producción, o al menos validar que esté configurado.

HALLAZGO #5: No hay TTL para sesiones
Severidad: MEDIA
Ubicación: saveSession() (línea 958)
Qué puede pasar: Las sesiones se acumulan indefinidamente. Con 250,000 IDs posibles, eventualmente se llenará el disco. Además, viola principio de retención 48h mencionado en documentación.
Cómo se detecta en logs: No hay logging. Se detectaría viendo crecimiento de TRANSCRIPTS_DIR.
Qué debería existir: Cron job o limpieza periódica que borre sesiones > 48h sin actividad.

HALLAZGO #6: No se valida VALID_TRANSITIONS en handlers
Severidad: MEDIA
Ubicación: VALID_TRANSITIONS definido (líneas 1293-1320) pero no usado
Qué puede pasar: Un bug podría hacer que el stage salte de ASK_LANGUAGE a ENDED, rompiendo el flujo. O retroceda sin motivo.
Cómo se detecta en logs: Se detectaría viendo transiciones inválidas en logs de stage changes.
Qué debería existir: Validar transición en changeStage() antes de actualizar session.stage.

HALLAZGO #7: /api/simulations/run no tiene autenticación ni rate limit
Severidad: ALTA
Ubicación: línea 9470
Qué puede pasar: Un atacante podría ejecutar simulaciones masivas (count: 10000, maxSteps: 10000), saturando el servidor y consumiendo recursos (llamadas a /api/chat, escrituras a disco).
Cómo se detecta en logs: Se verían muchas simulaciones ejecutándose simultáneamente.
Qué debería existir: Autenticación obligatoria (ADMIN_TOKEN) y rate limit específico (ej: 10 simulaciones/hora por IP).

HALLAZGO #8: No hay límite de tamaño de userText
Severidad: BAJA-MEDIA
Ubicación: /api/chat endpoint (línea 8898)
Qué puede pasar: Aunque express.json tiene limit: '10mb', un usuario podría enviar userText de varios MB, causando procesamiento lento y alto uso de memoria.
Cómo se detecta en logs: No hay logging específico. Se detectaría viendo requests con body muy grande.
Qué debería existir: Validación explícita: userText máximo 5000 caracteres.

HALLAZGO #9: No hay timeout para operaciones de OpenAI
Severidad: MEDIA
Ubicación: llamadas a OpenAI (línea 5647+)
Qué puede pasar: Si OpenAI tarda mucho en responder (o no responde), la request se cuelga indefinidamente, consumiendo recursos del servidor.
Cómo se detecta en logs: Requests que tardan mucho tiempo (> 30s) sin completar.
Qué debería existir: Timeout en cliente OpenAI (ej: 30 segundos) con fallback a respuesta genérica.

HALLAZGO #10: No hay rotación de logs
Severidad: BAJA
Ubicación: LOG_FILE y TELEMETRY_LOG (líneas 137-138)
Qué puede pasar: Los archivos de log crecen indefinidamente, llenando el disco eventualmente.
Cómo se detecta en logs: Crecimiento continuo de server.log y telemetry.log.
Qué debería existir: Rotación de logs (pino-rotate o similar) con retención de N días.

================================================================================
4. ANEXO TÉCNICO
================================================================================

INVENTARIO DE ENDPOINTS
================================================================================
GET  /                    → Sirve index.html (línea 532)
GET  /api/health          → Health check (línea 479)
POST /api/upload-image    → Subir imagen (línea 8278)
GET  /api/historial/:sessionId → Obtener historial (línea 8487)
GET  /api/transcript-json/:sessionId → Obtener transcript JSON (línea 8601)
GET  /api/greeting        → Iniciar nueva conversación (línea 8714)
POST /api/chat           → Procesar mensajes (línea 8898)
POST /api/simulations/run → Ejecutar simulaciones (línea 9470)
GET  /api/simulations/logs → Obtener logs de simulaciones (línea 9545)
GET  /api/simulations/log/:simulationId → Obtener log específico (línea 9570)

INVENTARIO DE STAGES Y HANDLERS
================================================================================
Stage: ASK_LANGUAGE
  Handler: handleAskLanguageStage() (líneas 1515-2466)
  Transiciones válidas: → ASK_NAME
  Entradas: buttonToken ('si', 'no'), userText

Stage: ASK_NAME
  Handler: handleAskNameStage() (líneas 2467-3097)
  Transiciones válidas: → ASK_NEED
  Entradas: userText

Stage: ASK_NEED
  Handler: handleAskNeedStage() (líneas 3098-4621)
  Transiciones válidas: → ASK_DEVICE, ASK_PROBLEM
  Entradas: buttonToken (problemas), userText

Stage: ASK_PROBLEM
  Handler: (no existe handler específico, se maneja en otros handlers)
  Transiciones válidas: → ASK_DEVICE

Stage: ASK_DEVICE
  Handler: handleAskDeviceStage() (líneas 4622-5706)
  Transiciones válidas: → BASIC_TESTS, ASK_PROBLEM
  Entradas: buttonToken (dispositivos), userText

Stage: BASIC_TESTS
  Handler: handleBasicTestsStage() (líneas 5707-7555)
  Transiciones válidas: → ESCALATE, ENDED
  Entradas: buttonToken (BTN_HELP_STEP_X, BTN_SOLVED, BTN_PERSIST, BTN_ESCALATE), userText

Stage: ESCALATE
  Handler: handleEscalateStage() (líneas 7556-7696)
  Transiciones válidas: → CREATE_TICKET, ENDED
  Entradas: buttonToken, userText

Stage: ENDED
  Handler: (no hay handler, es estado final)
  Transiciones válidas: (ninguna)

INVENTARIO DE TOKENS/BOTONES RELEVANTES
================================================================================
Botones de GDPR/Idioma:
  - 'si' / 'yes' → Aceptar consentimiento + seleccionar idioma
  - 'no' → Rechazar consentimiento

Botones de Idioma:
  - BTN_LANG_ES_AR → Español (Argentina)
  - BTN_LANG_EN → English

Botones de Problemas:
  - BTN_NO_ENCIENDE → El equipo no enciende
  - BTN_NO_INTERNET → Problemas de conexión
  - BTN_LENTITUD → Lentitud del sistema
  - BTN_BLOQUEO → Bloqueo de programas
  - BTN_PERIFERICOS → Problemas con periféricos
  - BTN_VIRUS → Infecciones de virus

Botones de Dispositivos:
  - BTN_DEVICE_PC → PC de escritorio
  - BTN_DEVICE_NOTEBOOK → Notebook
  - BTN_DEVICE_AIO → All-in-one

Botones de Pasos:
  - BTN_HELP_STEP_X → Ayuda para paso X (X = 0, 1, 2, ...)
  - BTN_SOLVED → Lo pude solucionar
  - BTN_PERSIST → El problema persiste
  - BTN_ESCALATE → Necesito hablar con un técnico
  - BTN_BACK_TO_STEPS → Volver a los pasos
  - BTN_BACK → Volver atrás

INVENTARIO DE PERSISTENCIA
================================================================================
Sesiones:
  - Ubicación: TRANSCRIPTS_DIR/{sessionId}.json
  - Formato: JSON con objeto session completo
  - TTL: ❌ No hay TTL (se guardan indefinidamente)
  - Simulaciones: Prefijo SIM_ (línea 976)

Transcripts:
  - Ubicación: TRANSCRIPTS_DIR/{sessionId}.txt
  - Formato: Texto plano legible
  - TTL: ❌ No hay TTL

Historial:
  - Ubicación: HISTORIAL_CHAT_DIR/{sessionId}.json
  - Formato: JSON estructurado para admin panel
  - TTL: ❌ No hay TTL

Tickets:
  - Ubicación: TICKETS_DIR/{ticketId}.txt y {ticketId}.json
  - Formato: .txt legible y .json estructurado
  - TTL: ❌ No hay TTL

Simulaciones:
  - Ubicación: data/simulations/sim_{simulationId}.json (en simulation-engine.js)
  - Formato: JSON con resultado completo
  - TTL: ❌ No hay TTL

Logs:
  - Ubicación: LOGS_DIR/server.log y telemetry.log
  - Formato: Texto plano (server.log) y JSONL (telemetry.log)
  - Rotación: ❌ No hay rotación

Uploads:
  - Ubicación: UPLOADS_DIR/{sessionId}_{timestamp}_{random}.{ext}
  - Formato: Imágenes (JPEG, PNG, GIF, WebP)
  - TTL: ❌ No hay TTL

INVENTARIO DE RATE LIMITS Y CORS
================================================================================
Rate Limits:
  - Global: 100 requests/15min por IP (líneas 428-437)
  - Uploads: 10 requests/5min por IP (líneas 7966-7976)
  - /api/chat: ❌ No hay rate limit específico
  - /api/simulations/run: ❌ No hay rate limit específico
  - Endpoints admin: ❌ No hay rate limit específico

CORS:
  - Orígenes permitidos: Configurables vía ALLOWED_ORIGINS (línea 289)
  - Defaults: stia.com.ar, www.stia.com.ar, localhost:3000, localhost:5500
  - Requests sin origin: ✅ Permitidos (línea 323-325)
  - Credentials: ✅ Habilitado (línea 340)
  - Métodos: GET, POST, PUT, DELETE, OPTIONS (línea 342)
  - Headers: Content-Type, Authorization, x-session-id, x-locale, x-lang (línea 343)

INVENTARIO DE GUARD RAILS (INCLUYENDO SIMULACIÓN)
================================================================================
Guard Rails de Simulación:
  1. saveSession() (línea 972): Si session.simulation === true, usa prefijo SIM_ y no guarda en producción
  2. createTicketAndRespond() (línea 6950): Si session.simulation === true, retorna placeholder SIM_WHATSAPP
  3. pushBasicTestTelemetry() (línea 859): Si session.simulation === true, no actualiza PROBLEM_METRICS
  4. WhatsApp URLs (líneas 7231-7236, referenciadas): Si session.simulation === true, retorna 'SIM_WHATSAPP'
  5. /api/chat (línea 8903): Detecta req.body.simulation === true y marca sesión como simulación

Guard Rails de Flujo:
  1. Anti-reimpresión de pasos (líneas 4720-4747, 5776-5850): Previene reimprimir pasos cuando hay progreso
  2. Anti-escalamiento prematuro (líneas 3100-3244): Previene WhatsApp en ASK_NEED sin frustración
  3. Validación de sessionId (línea 834): Formato A0000-Z9999
  4. Locks de tickets (líneas 6976-6993): Previene creación simultánea de tickets

Guard Rails de Seguridad:
  1. Path traversal en uploads (líneas 8033-8040): Verifica que resolvedPath esté dentro de UPLOADS_DIR
  2. Validación de imágenes (líneas 8149-8199): Magic numbers + sharp
  3. Sanitización de nombres de archivo (línea 8030): Elimina caracteres peligrosos
  4. Enmascaramiento de PII (líneas 6730-6780): maskPII() enmascara información sensible

================================================================================
FIN DEL INFORME
================================================================================

