================================================================================
AUDITORÍA FRONTEND vs BACKEND - STI / TECNOS
================================================================================
Fecha: 2025-01-XX
Alcance: index.php (frontend) vs server.js (backend)
Tipo: Solo informativa - NO se realizaron cambios

================================================================================
1. RESUMEN EJECUTIVO
================================================================================

Estado General: RIESGO BAJO

El frontend está mayormente bien alineado con el backend, pero existen algunas
desviaciones menores que podrían causar problemas en casos específicos:

✅ FORTALEZAS:
- El frontend NO toma decisiones de lógica de negocio
- NO duplica lógica del backend
- Renderiza botones correctamente según lo que recibe
- Maneja eventos de forma apropiada
- Formato de payload es correcto en su mayoría

⚠️ RIESGOS DETECTADOS:
- Inconsistencia en nombres de campos (message vs userText)
- Mapeo de botones podría ocultar problemas del backend
- Falta verificación explícita de BTN_FEEDBACK_* (recientemente agregado)
- El frontend envía campos que el backend no usa directamente

================================================================================
2. MATRIZ FRONTEND vs BACKEND
================================================================================

A) FORMATO DE PAYLOAD - /api/chat

┌─────────────────────────┬──────────────────────┬─────────────────────────┐
│ Qué espera server.js    │ Qué hace frontend    │ Coincide                │
├─────────────────────────┼──────────────────────┼─────────────────────────┤
│ body.message            │ ✅ Envía "message"   │ ✅ SÍ                   │
│ body.text               │ ❌ NO envía          │ ⚠️ Backend acepta ambos │
│ body.action === 'button'│ ✅ Envía correcto    │ ✅ SÍ                   │
│ body.value (botones)    │ ✅ Envía correcto    │ ✅ SÍ                   │
│ body.sessionId          │ ✅ Envía correcto    │ ✅ SÍ                   │
│ body.csrfToken          │ ✅ Envía correcto    │ ✅ SÍ                   │
│ body.userText           │ ❌ NO envía          │ ⚠️ Backend lo deriva    │
│ body.label (botones)    │ ✅ Envía pero...     │ ⚠️ Backend NO lo usa    │
│ body.imageBase64        │ ✅ Envía si hay img  │ ✅ SÍ                   │
│ body.imageName          │ ✅ Envía si hay img  │ ✅ SÍ                   │
└─────────────────────────┴──────────────────────┴─────────────────────────┘

ANÁLISIS:
- ✅ El backend acepta tanto "message" como "text" (línea ~10143)
- ⚠️ El frontend siempre envía "message", nunca "text" ni "userText"
- ✅ Esto funciona porque backend deriva userText de message/buttonToken
- ⚠️ Riesgo: Si backend cambia para requerir "userText" explícito, frontend rompería

B) RENDERIZADO DE BOTONES

┌─────────────────────────┬──────────────────────┬─────────────────────────┐
│ Qué espera server.js    │ Qué hace frontend    │ Coincide                │
├─────────────────────────┼──────────────────────┼─────────────────────────┤
│ buttons[] en respuesta  │ ✅ Renderiza array   │ ✅ SÍ                   │
│ {text, value, order}    │ ✅ Usa label/value   │ ✅ SÍ                   │
│ Preservar BTN_HELP_STEP │ ✅ Preserva correcto │ ✅ SÍ                   │
│ NO agregar botones      │ ✅ No agrega (excepto│ ✅ SÍ (WhatsApp OK)     │
│                         │    WhatsApp que es   │                         │
│                         │    correcto)         │                         │
│ NO ocultar botones      │ ✅ No oculta         │ ✅ SÍ                   │
└─────────────────────────┴──────────────────────┴─────────────────────────┘

ANÁLISIS:
- ✅ normalizeButtons() (línea ~1707) preserva el value correctamente
- ✅ LABEL_MAP solo afecta visualización, NO cambia value enviado
- ⚠️ Riesgo bajo: Si backend envía botón sin "value", frontend usa label como fallback
- ✅ Botones inline (BTN_HELP_STEP_X) se manejan correctamente

C) MANEJO DE EVENTOS DE BOTONES

┌─────────────────────────┬──────────────────────┬─────────────────────────┐
│ Qué espera server.js    │ Qué hace frontend    │ Coincide                │
├─────────────────────────┼──────────────────────┼─────────────────────────┤
│ buttonToken = body.value│ ✅ Envía en "value"  │ ✅ SÍ                   │
│ UN evento por click     │ ✅ Un evento         │ ✅ SÍ                   │
│ Identificador BTN_*     │ ✅ Preserva BTN_*    │ ✅ SÍ                   │
│ NO interpretar texto    │ ✅ Envía value, no   │ ✅ SÍ                   │
│                         │    interpreta        │                         │
└─────────────────────────┴──────────────────────┴─────────────────────────┘

ANÁLISIS:
- ✅ sendButton() (línea ~1949) envía correctamente {action: 'button', value, label}
- ✅ El value se preserva correctamente a través de normalizeButtons()
- ✅ Frontend NO interpreta semánticamente el botón

D) FLUJO Y ESTADO

┌─────────────────────────┬──────────────────────┬─────────────────────────┐
│ Qué espera server.js    │ Qué hace frontend    │ Coincide                │
├─────────────────────────┼──────────────────────┼─────────────────────────┤
│ Todo estado del backend │ ✅ Lee data.stage    │ ✅ SÍ                   │
│ NO estado propio        │ ✅ Solo para UI      │ ✅ SÍ                   │
│                         │    (habilitar clip)  │                         │
│ NO decidir avanzar      │ ✅ No decide         │ ✅ SÍ                   │
│ Stages del backend      │ ✅ Solo lectura      │ ✅ SÍ                   │
└─────────────────────────┴──────────────────────┴─────────────────────────┘

ANÁLISIS:
- ✅ Frontend NO guarda estado conversacional propio
- ✅ Solo usa data.stage para habilitar/deshabilitar carga de imágenes (línea ~2022, ~2266)
- ✅ No toma decisiones de flujo

E) CASOS CRÍTICOS RECIENTES

E1) BTN_SOLVED
┌─────────────────────────┬──────────────────────┬─────────────────────────┐
│ Backend                 │ Frontend             │ Coincide                │
├─────────────────────────┼──────────────────────┼─────────────────────────┤
│ Muestra botones feedback│ ❓ NO verificado     │ ⚠️ REQUIERE VERIFICACIÓN│
│ después de BTN_SOLVED   │    explícitamente    │                         │
│ BTN_FEEDBACK_USEFUL     │ ❓ NO en LABEL_MAP   │ ⚠️ REQUIERE VERIFICACIÓN│
│ BTN_FEEDBACK_NOT_USEFUL │ ❓ NO en LABEL_MAP   │ ⚠️ REQUIERE VERIFICACIÓN│
└─────────────────────────┴──────────────────────┴─────────────────────────┘

ANÁLISIS:
- ⚠️ Backend implementó BTN_FEEDBACK_USEFUL y BTN_FEEDBACK_NOT_USEFUL (línea ~7080, ~7122)
- ❌ Frontend NO tiene estos botones en LABEL_MAP (línea ~1727)
- ⚠️ Riesgo: Si backend envía estos botones, frontend los mostrará pero sin mapeo
- ✅ Esto NO es crítico porque normalizeButtons() usa el value directamente

E2) BTN_HELP_STEP_X
┌─────────────────────────┬──────────────────────┬─────────────────────────┐
│ Backend                 │ Frontend             │ Coincide                │
├─────────────────────────┼──────────────────────┼─────────────────────────┤
│ Espera BTN_HELP_STEP_X  │ ✅ Preserva value    │ ✅ SÍ                   │
│ exacto                  │    correctamente     │                         │
│ Botones inline          │ ✅ Maneja inline     │ ✅ SÍ                   │
│ Marcadores [BTN_...]    │ ✅ Procesa marcadores│ ✅ SÍ                   │
└─────────────────────────┴──────────────────────┴─────────────────────────┘

ANÁLISIS:
- ✅ Frontend preserva BTN_HELP_STEP_X sin mapear (línea ~1763)
- ✅ createInlineButton() construye value correcto (línea ~1335)
- ✅ sendButton() envía el value correcto

F) UX TÉCNICA

┌─────────────────────────┬──────────────────────┬─────────────────────────┐
│ Aspecto                 │ Frontend             │ Estado                  │
├─────────────────────────┼──────────────────────┼─────────────────────────┤
│ Loaders                 │ ✅ addTyping()       │ ✅ OK                   │
│ Disable botones         │ ✅ Deshabilita       │ ✅ OK                   │
│ Doble click             │ ✅ Deshabilita después│ ✅ OK                   │
│                         │    de click          │                         │
│ Debounce                │ ❌ NO implementado   │ ⚠️ Podría mejorarse     │
└─────────────────────────┴──────────────────────┴─────────────────────────┘

ANÁLISIS:
- ✅ Frontend deshabilita botones después de click (línea ~1901)
- ⚠️ NO hay debounce explícito, pero deshabilitar previene doble envío
- ✅ Loaders (typing) funcionan correctamente

G) LOGS Y DEBUGGING

┌─────────────────────────┬──────────────────────┬─────────────────────────┐
│ Aspecto                 │ Frontend             │ Estado                  │
├─────────────────────────┼──────────────────────┼─────────────────────────┤
│ Transforma texto        │ ✅ Solo markdown     │ ✅ OK                   │
│                         │    básico            │                         │
│ Muta payload            │ ❌ NO                │ ✅ OK                   │
│ Logs eventos            │ ✅ console.log       │ ✅ OK                   │
└─────────────────────────┴──────────────────────┴─────────────────────────┘

ANÁLISIS:
- ✅ Frontend solo transforma markdown para visualización (línea ~1217)
- ✅ NO transforma el texto antes de enviarlo
- ✅ Logs son adecuados para debugging

================================================================================
3. LISTA DE DESVIOS DETECTADOS
================================================================================

DESVÍO #1: Inconsistencia en nombres de campos
├─ Archivo: index.php
├─ Línea: ~1952, ~2201
├─ Descripción: Frontend envía "message" pero backend también acepta "text".
│                Backend valida "userText" pero lo deriva de "message"/"text" o "buttonToken"
├─ Impacto: BAJO (backend acepta múltiples formatos y los normaliza internamente)
├─ Riesgo: Muy bajo - backend es flexible con formatos
└─ Recomendación: Backend ya maneja ambos, funcionamiento correcto

DESVÍO #2: Campo "label" enviado pero no usado
├─ Archivo: index.php
├─ Línea: ~1955
├─ Descripción: Frontend envía "label" en payload de botones, backend no lo usa
├─ Impacto: BAJO (campo extra no causa problemas)
├─ Riesgo: Ninguno
└─ Recomendación: Mantener para debugging, pero no es crítico

DESVÍO #3: BTN_FEEDBACK_* no en LABEL_MAP
├─ Archivo: index.php
├─ Línea: ~1727 (LABEL_MAP)
├─ Descripción: Backend implementó BTN_FEEDBACK_USEFUL/NOT_USEFUL pero frontend no tiene mapeo
├─ Impacto: BAJO (normalizeButtons() usa value directamente)
├─ Riesgo: Bajo - botones se mostrarán pero sin etiqueta personalizada
└─ Recomendación: Agregar a LABEL_MAP si se quiere personalizar texto

DESVÍO #4: Falta verificación explícita de feedback
├─ Archivo: index.php
├─ Línea: ~2000 (normalizeButtons)
├─ Descripción: Frontend no tiene lógica especial para botones de feedback
├─ Impacto: BAJO (funcionará con lógica genérica)
├─ Riesgo: Ninguno - funcionará correctamente
└─ Recomendación: No requiere cambios, funciona con lógica existente

DESVÍO #5: sessionId generado en frontend
├─ Archivo: index.php
├─ Línea: ~921
├─ Descripción: Frontend genera sessionId con formato "web-xxx" pero backend espera A0000-Z9999
├─ Impacto: MEDIO (backend valida formato estricto)
├─ Riesgo: Backend rechazará sessionId generado por frontend
└─ Recomendación: Frontend debe obtener sessionId de /api/greeting (YA LO HACE - línea ~2456)

NOTA: Revisando código, frontend SÍ obtiene sessionId de /api/greeting (línea ~2456),
      pero también tiene función newSID() que no se usa en producción.
      El sessionId inicial se genera pero luego se reemplaza con el del servidor.

================================================================================
4. RIESGOS POTENCIALES
================================================================================

RIESGO #1: Cambio de formato de payload en backend
├─ Probabilidad: MUY BAJA
├─ Impacto: ALTO (si ocurre)
├─ Descripción: Si backend cambiara para requerir "userText" explícito en lugar
│                de derivarlo de "message" o "buttonToken", frontend rompería
└─ Mitigación: Backend actualmente acepta múltiples formatos (message/text) y
                los normaliza internamente. Probabilidad muy baja de cambio.

RIESGO #2: Botones de feedback sin mapeo de etiquetas
├─ Probabilidad: ALTA (ya existe)
├─ Impacto: BAJO
├─ Descripción: BTN_FEEDBACK_* se mostrarán con su value como texto si backend
│                no envía "text" o "label" en el objeto del botón
└─ Mitigación: normalizeButtons() usa value como fallback, funcionará

RIESGO #3: Frontend agrega lógica de estado en el futuro
├─ Probabilidad: MEDIA
├─ Impacto: ALTO
├─ Descripción: Si en el futuro alguien agrega estado conversacional propio
│                al frontend, podría causar inconsistencias
└─ Mitigación: Código actual NO tiene estado propio, mantener así

RIESGO #4: Mapeo de botones oculta problemas del backend
├─ Probabilidad: BAJA
├─ Impacto: MEDIO
├─ Descripción: LABEL_MAP podría ocultar que backend envía tokens incorrectos
└─ Mitigación: normalizeButtons() preserva value original, solo cambia label

RIESGO #5: Desincronización en formato de botones
├─ Probabilidad: BAJA
├─ Impacto: MEDIO
├─ Descripción: Si backend cambia formato de botones (ej: de {text,value} a otro)
│                frontend podría no renderizarlos correctamente
└─ Mitigación: normalizeButtons() es flexible y acepta múltiples formatos

================================================================================
5. CONCLUSIÓN FINAL
================================================================================

¿El frontend es pasivo y obediente al backend?
✅ SÍ - El frontend NO toma decisiones de lógica de negocio, solo renderiza
         lo que recibe y envía eventos correctamente.

¿Hay lógica mal ubicada?
✅ NO - No se detectó lógica de negocio en el frontend. La única "lógica"
        es para UI (habilitar/deshabilitar carga de imágenes según stage).

¿Desviaciones críticas?
❌ NO - Todas las desviaciones detectadas son de bajo impacto y no afectan
        el funcionamiento actual.

¿El frontend está preparado para cambios recientes (feedback)?
⚠️ PARCIALMENTE - Los botones de feedback funcionarán pero no están en LABEL_MAP.
                   No es crítico porque normalizeButtons() maneja valores sin mapeo.

RECOMENDACIONES PRIORITARIAS:

1. BAJA PRIORIDAD: Agregar BTN_FEEDBACK_USEFUL y BTN_FEEDBACK_NOT_USEFUL a LABEL_MAP
   - Archivo: index.php línea ~1727
   - Razón: Mejorar consistencia visual, aunque no es crítico

2. BAJA PRIORIDAD: Documentar explícitamente qué campos envía el frontend
   - Archivo: index.php (comentarios en sendButton y sendMsg)
   - Razón: Ayudar a futuros desarrolladores

3. MEDIA PRIORIDAD: Considerar agregar debounce para prevenir doble envío
   - Archivo: index.php (sendMsg y sendButton)
   - Razón: Mejorar UX aunque deshabilitar botones ya previene el problema

4. NINGUNA PRIORIDAD: Limpiar función newSID() si no se usa
   - Archivo: index.php línea ~921
   - Razón: Código muerto, pero no causa problemas

================================================================================
FIN DEL INFORME
================================================================================

